---
title: "CCR2+ neutrophils"
output: html_notebook
---

#LOADING PACKAGES
```{r}
# Function to install packages if not already installed
install_if_missing <- function(pkg) {
  # Check if the package is installed from CRAN or Bioconductor
  if (!requireNamespace(pkg, quietly = TRUE)) {
    if (pkg %in% c("SingleCellExperiment", "DropletUtils", "scater", "scran", "edgeR", 
                  "limma", "slingshot", "Seurat", "tradeSeq", "AUCell", "CiteFuse", 
                  "celldex", "SingleR", "bluster", "mumosa", "batchelor", "HGNChelper", 
                  "harmony", "dyno")) {
      # Bioconductor packages
      BiocManager::install(pkg)
    } else {
      # CRAN packages
      install.packages(pkg)
    }
  }
}

# List of required packages
packages <- c("SingleCellExperiment", "DropletUtils", "scater", "scran", "edgeR", 
              "ggrepel", "EnhancedVolcano", "ggpubr", "VennDiagram", "RColorBrewer", 
              "org.Mm.eg.db", "limma", "dplyr", "slingshot", "Seurat", "tradeSeq", 
              "tidyverse", "tidymodels", "scales", "viridis", "Matrix", "gam", "destiny", 
              "GSEABase", "AUCell", "CiteFuse", "celldex", "SingleR", "pheatmap", 
              "ggvenn", "bluster", "mumosa", "batchelor", "HGNChelper", "harmony", 
              "scplotter", "CreateGeneSignatures", "plotthis", "dyno")

# Install missing packages
for (pkg in packages) {
  install_if_missing(pkg)
}

# Load all the packages
suppressPackageStartupMessages({
  library(SingleCellExperiment)
  library(DropletUtils)
  library(scater)
  library(scran)
  library(edgeR)
  library(ggrepel)
  library(EnhancedVolcano)
  library(ggpubr)
  library(VennDiagram)
  library(RColorBrewer)
  library(org.Mm.eg.db)
  library(limma)
  library(dplyr)
  library(slingshot)
  library(Seurat)
  library(tradeSeq)
  library(tidyverse)
  library(tidymodels)
  library(scales)
  library(viridis)
  library(Matrix)
  library(gam)
  library(destiny)
  library(GSEABase)
  library(AUCell)
  library(CiteFuse)
  library(celldex)
  library(SingleR)
  library(pheatmap)
  library(ggvenn)
  library(bluster)
  library(mumosa)
  library(batchelor)
  library(HGNChelper)
  library(harmony)
  library(SingleR)
  #library(scplotter)
  library(CreateGeneSignatures)
  library(plotthis)
  library(dyno)
  library(DelayedArray)
  library("escape")
})

```

Cochain et al. 
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE97310
#11wks HFD_
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/10X_Matrices_CircRes2018/Cochain_2018_11weeks_HFD"

# Build the file paths
barcode_path <- file.path(dir, "barcodes.tsv")
gene_path    <- file.path(dir, "genes.tsv")
matrix_path  <- file.path(dir, "matrix.mtx")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_11wks <- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```

#20wks HFD
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/10X_Matrices_CircRes2018/Cochain_2018_20weeks_HFD"

# Build the file paths
barcode_path <- file.path(dir, "barcodes.tsv")
gene_path    <- file.path(dir, "genes.tsv")
matrix_path  <- file.path(dir, "matrix.mtx")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_20wks <- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```

#Control_diet
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/10X_Matrices_CircRes2018/Cochain_2018_healthy_aorta"

# Build the file paths
barcode_path <- file.path(dir, "barcodes.tsv")
gene_path    <- file.path(dir, "genes.tsv")
matrix_path  <- file.path(dir, "matrix.mtx")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```


```{r}
sce_control <- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE123587
Lin JD, Nishi H, Poles J, Niu X et al. Single-cell analysis of fate-mapped macrophages reveals heterogeneity, including stem-like properties, during atherosclerosis progression and regression. JCI Insight 2019 Feb 21;4(4). PMID: 30830865
#GSE123587
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/GSE123587_RAW/Progression"

# Build the file paths
barcode_path <- file.path(dir, "GSM3507490_progression_barcodes.tsv.gz")
gene_path    <- file.path(dir, "GSM3507490_progression_genes.tsv.gz")
matrix_path  <- file.path(dir, "GSM3507490_progression_matrix.mtx.gz")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_GSE123587 <- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE154817
Williams JW, Zaitsev K, Kim KW, Ivanov S et al. Limited proliferation capacity of aortic intima resident macrophages requires monocyte recruitment for atherosclerotic plaque progression. Nat Immunol 2020 Oct;21(10):1194-1204. PMID: 32895539
#GSE154817
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/GSE154817_RAW/D21_HFD"

# Build the file paths
barcode_path <- file.path(dir, "GSM4680683_D21HFD_barcodes.tsv.gz")
gene_path    <- file.path(dir, "GSM4680683_D21HFD_genes.tsv.gz")
matrix_path  <- file.path(dir, "GSM4680683_D21HFD_matrix.mtx.gz")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_GSE154817<- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```

http://ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE252243
Cyr Y, Bozal FK, Barcia Durán JG, Newman AAC et al. The IRG1-itaconate axis protects from cholesterol-induced inflammation and atherosclerosis. Proc Natl Acad Sci U S A 2024 Apr 9;121(15):e2400675121. PMID: 38564634
Barcia Durán JG, Das D, Gildea M, Amadori L et al. Immune checkpoint landscape of human atherosclerosis and influence of cardiometabolic factors. Nat Cardiovasc Res 2024 Dec;3(12):1482-1502. PMID: 39613875
#GSE252243
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/GSE252243_RAW.gz"

# Build the file paths
barcode_path <- file.path(dir, "GSM7997955_WT_barcodes.tsv.gz")
gene_path    <- file.path(dir, "GSM7997955_WT_features.tsv.gz")
matrix_path  <- file.path(dir, "GSM7997955_WT_matrix.mtx.gz")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_GSE252243 <- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```


https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE116240
Kim K, Shim D, Lee JS, Zaitsev K et al. Transcriptome Analysis Reveals Nonfoamy Rather Than Foamy Plaque Macrophages Are Proinflammatory in Atherosclerotic Murine Models. Circ Res 2018 Oct 26;123(10):1127-1142. PMID: 30359200
#GSE116240
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/GSE116240_RAW"

# Build the file paths
barcode_path <- file.path(dir, "GSM3215435_ldlr_ko_barcodes.tsv.gz")
gene_path    <- file.path(dir, "GSM3215435_ldlr_ko_genes.tsv.gz")
matrix_path  <- file.path(dir, "GSM3215435_ldlr_ko_matrix.mtx.gz")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_GSE116240_LDL_leuko <- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```

```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/GSE116240_RAW"

# Build the file paths
barcode_path <- file.path(dir, "GSM3215436_total_foam_barcodes.tsv.gz")
gene_path    <- file.path(dir, "GSM3215436_total_foam_genes.tsv.gz")
matrix_path  <- file.path(dir, "GSM3215436_total_foam_matrix.mtx.gz")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_GSE116240_LDL_foam_cells <- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM4981311
```{r}
# Set the base directory
dir <- "~/Dropbox/Backup_Work/Scripts/Databases/GSM4981311"

# Build the file paths
barcode_path <- file.path(dir, "barcodes.tsv")
gene_path    <- file.path(dir, "GSM4981311_Control_features.tsv")
matrix_path  <- file.path(dir, "matrix.mtx")

# Load the data
barcodes   <- read.table(barcode_path, header = FALSE, stringsAsFactors = FALSE)
genes      <- read.table(gene_path, header = FALSE, stringsAsFactors = FALSE)
matrix_data <- Matrix::readMM(matrix_path)

# Use gene symbols as row names
rownames(matrix_data) <- genes$V2

```

```{r}
sce_GSM4981311<- SingleCellExperiment(
  assays = list(counts = matrix_data),
  rowData = genes,
  colData = barcodes
)
```


#Loading own dataset
```{r}
filename <- file.choose()
sce <- readRDS(filename)
```

#Combining all datasets
```{r}
# 1. Identify common genes across all nine SingleCellExperiment objects
common_genes <- Reduce(intersect, list(
  rownames(sce_11wks), 
  rownames(sce_20wks), 
  rownames(sce_control),
  rownames(sce_GSE123587),
  rownames(sce_GSE154817),
  rownames(sce_GSE252243),
  rownames(sce_GSE116240_LDL_leuko),
  rownames(sce_GSE116240_LDL_foam_cells),
  rownames(sce_GSM4981311)
))

# 2. Subset each SingleCellExperiment object to keep only common genes
sce_11wks                    <- sce_11wks[common_genes, ]
sce_20wks                    <- sce_20wks[common_genes, ]
sce_control                  <- sce_control[common_genes, ]
sce_GSE123587                <- sce_GSE123587[common_genes, ]
sce_GSE154817                <- sce_GSE154817[common_genes, ]
sce_GSE252243                <- sce_GSE252243[common_genes, ]
sce_GSE116240_LDL_leuko      <- sce_GSE116240_LDL_leuko[common_genes, ]
sce_GSE116240_LDL_foam_cells <- sce_GSE116240_LDL_foam_cells[common_genes, ]
sce_GSM4981311               <- sce_GSM4981311[common_genes, ]

# 2a. Standardize rowData to avoid duplicated/conflicting metadata columns.
# Replace rowData with a simple DataFrame containing just the gene IDs.
common_rowdata <- DataFrame(gene_id = common_genes, row.names = common_genes)
rowData(sce_11wks)                    <- common_rowdata
rowData(sce_20wks)                    <- common_rowdata
rowData(sce_control)                  <- common_rowdata
rowData(sce_GSE123587)                <- common_rowdata
rowData(sce_GSE154817)                <- common_rowdata
rowData(sce_GSE252243)                <- common_rowdata
rowData(sce_GSE116240_LDL_leuko)      <- common_rowdata
rowData(sce_GSE116240_LDL_foam_cells) <- common_rowdata
rowData(sce_GSM4981311)               <- common_rowdata

# 3. Prepare condition vectors for each dataset
condition_11wks                    <- rep("11wks", ncol(sce_11wks))
condition_20wks                    <- rep("20wks", ncol(sce_20wks))
condition_control                  <- rep("control", ncol(sce_control))
condition_GSE123587                <- rep("GSE123587", ncol(sce_GSE123587))
condition_GSE154817                <- rep("GSE154817", ncol(sce_GSE154817))
condition_GSE252243                <- rep("GSE252243", ncol(sce_GSE252243))
condition_GSE116240_LDL_leuko      <- rep("GSE116240_LDL_leuko", ncol(sce_GSE116240_LDL_leuko))
condition_GSE116240_LDL_foam_cells <- rep("GSE116240_LDL_foam_cells", ncol(sce_GSE116240_LDL_foam_cells))
condition_sce_GSM4981311           <- rep("sce_GSM4981311", ncol(sce_GSM4981311))

# 4. Add the condition information to each object's colData
colData(sce_11wks)$Condition                    <- condition_11wks
colData(sce_20wks)$Condition                    <- condition_20wks
colData(sce_control)$Condition                  <- condition_control
colData(sce_GSE123587)$Condition                <- condition_GSE123587
colData(sce_GSE154817)$Condition                <- condition_GSE154817
colData(sce_GSE252243)$Condition                <- condition_GSE252243
colData(sce_GSE116240_LDL_leuko)$Condition      <- condition_GSE116240_LDL_leuko
colData(sce_GSE116240_LDL_foam_cells)$Condition <- condition_GSE116240_LDL_foam_cells
colData(sce_GSM4981311)$Condition               <- condition_sce_GSM4981311

# Overwrite colData to only include the "Condition" column
colData(sce_11wks) <- DataFrame(Condition = condition_11wks)
colData(sce_20wks) <- DataFrame(Condition = condition_20wks)
colData(sce_control) <- DataFrame(Condition = condition_control)
colData(sce_GSE123587) <- DataFrame(Condition = condition_GSE123587)
colData(sce_GSE154817) <- DataFrame(Condition = condition_GSE154817)
colData(sce_GSE252243) <- DataFrame(Condition = condition_GSE252243)
colData(sce_GSE116240_LDL_leuko) <- DataFrame(Condition = condition_GSE116240_LDL_leuko)
colData(sce_GSE116240_LDL_foam_cells) <- DataFrame(Condition = condition_GSE116240_LDL_foam_cells)
colData(sce_GSM4981311) <- DataFrame(Condition = condition_sce_GSM4981311)

# 5. Combine all datasets vertically
combined_sce <- cbind(
  sce_11wks,
  sce_20wks,
  sce_control,
  sce_GSE123587,
  sce_GSE154817,
  sce_GSE252243,
  sce_GSE116240_LDL_leuko,
  sce_GSE116240_LDL_foam_cells, 
  sce_GSM4981311
)

# 6. Verify the combined SingleCellExperiment object for the 'Condition' column
table(colData(combined_sce)$Condition)


```


```{r}
#––– 0. Load required packages
library(SingleCellExperiment)
library(S4Vectors)

#––– 1. List your SCE object names
sce_names <- c(
  "sce_11wks", "sce_20wks", "sce_control",
  "sce_GSE123587", "sce_GSE154817", "sce_GSE252243",
  "sce_GSE116240_LDL_leuko", "sce_GSE116240_LDL_foam_cells",
  "sce_GSM4981311", "sce"
)

#––– 2. Find genes common to all ten
common_genes <- Reduce(
  intersect,
  lapply(sce_names, function(nm) rownames(get(nm)))
)

#––– 3. Subset each SCE to those genes
for (nm in sce_names) {
  tmp <- get(nm)
  tmp <- tmp[common_genes, ]
  assign(nm, tmp, envir = .GlobalEnv)
}

#––– 4. Standardize rowData across all
common_rowdata <- DataFrame(gene_id = common_genes, row.names = common_genes)
for (nm in sce_names) {
  tmp <- get(nm)
  rowData(tmp) <- common_rowdata
  assign(nm, tmp, envir = .GlobalEnv)
}

#––– 5. Find assays common to all, then subset each
common_assays <- Reduce(
  intersect,
  lapply(sce_names, function(nm) assayNames(get(nm)))
)
for (nm in sce_names) {
  tmp <- get(nm)
  assays(tmp) <- assays(tmp)[common_assays]
  assign(nm, tmp, envir = .GlobalEnv)
}

#––– 6. Find reducedDims common to all, then subset each
common_rdims <- Reduce(
  intersect,
  lapply(sce_names, function(nm) reducedDimNames(get(nm)))
)
for (nm in sce_names) {
  tmp <- get(nm)
  reducedDims(tmp) <- reducedDims(tmp)[common_rdims]
  assign(nm, tmp, envir = .GlobalEnv)
}

#––– 7. Find altExps common to all, then prune each
common_alts <- Reduce(
  intersect,
  lapply(sce_names, function(nm) altExpNames(get(nm)))
)
for (nm in sce_names) {
  tmp <- get(nm)
  # drop any altExps not in common_alts
  for (ae in setdiff(altExpNames(tmp), common_alts)) {
    altExp(tmp, ae) <- NULL
  }
  assign(nm, tmp, envir = .GlobalEnv)
}

#––– 8. Prepare a Condition vector for your new `sce`
condition_sce <- rep("sce", ncol(sce))

#––– 9. Helper to set both Condition & Organ
set_cd <- function(obj, cond, organ) {
  cd <- colData(obj)
  cd$Condition <- cond
  cd$Organ     <- organ
  colData(obj) <- cd[, c("Condition","Organ"), drop = FALSE]
  obj
}

#––– 10. Annotate the nine original objects as Organ = "Aorta"
sce_11wks                    <- set_cd(sce_11wks,                    "11wks",                    "Aorta")
sce_20wks                    <- set_cd(sce_20wks,                    "20wks",                    "Aorta")
sce_control                  <- set_cd(sce_control,                  "control",                  "Aorta")
sce_GSE123587                <- set_cd(sce_GSE123587,                "GSE123587",                "Aorta")
sce_GSE154817                <- set_cd(sce_GSE154817,                "GSE154817",                "Aorta")
sce_GSE252243                <- set_cd(sce_GSE252243,                "GSE252243",                "Aorta")
sce_GSE116240_LDL_leuko      <- set_cd(sce_GSE116240_LDL_leuko,      "GSE116240_LDL_leuko",      "Aorta")
sce_GSE116240_LDL_foam_cells <- set_cd(sce_GSE116240_LDL_foam_cells, "GSE116240_LDL_foam_cells", "Aorta")
sce_GSM4981311               <- set_cd(sce_GSM4981311,               "sce_GSM4981311",           "Aorta")

#––– 11. Annotate your `sce` (keep its multiple Organs, add Condition)
cd_sce <- colData(sce)
cd_sce$Condition <- condition_sce
colData(sce) <- cd_sce[, c("Condition","Organ")]

#––– 12. Finally, combine all ten into one SingleCellExperiment
combined_sce <- do.call(cbind, mget(sce_names))

#––– 13. Sanity‐check the new metadata
print(table(colData(combined_sce)$Condition))
print(table(colData(combined_sce)$Organ))
```

#NORMALIZATION
```{r}
##############################################
#NORMALIZATION
#LIBRARY SIZE NORMALIZATION
set.seed(100)
combined_sce<- logNormCounts(combined_sce)
#convert to a seurat object if needed
#seurat_obj <- as.Seurat(sce_filtered, counts = "counts", data = "logcounts")

#PER-GENE VARIATION
dec.sce <- modelGeneVar(combined_sce)
chosen <- getTopHVGs(dec.sce, prop=1)
str(chosen)

#############################################
#DIMENSIONALITY REDUCTION: PCA Analysis
set.seed(1458847) 
combined_sce <- runPCA(combined_sce, subset_row = chosen, name = "PCA_HVGs") 
percent.var <- attr(reducedDim(combined_sce, 'PCA_HVGs'), 'percentVar')
cat("Percentage of variance explained by top PCs:", percent.var, "\n")

############################################
# RUN HARMONY TO REMOVE BATCH EFFECTS
set.seed(12345)
reducedDim(combined_sce, 'PCA_HVGs_corr') <- HarmonyMatrix(reducedDim(combined_sce, 'PCA_HVGs'), meta_data = colData(combined_sce), vars_use = 'Condition')

############################################
# RUN UMAPs
set.seed(20398) 
combined_sce <- runUMAP(combined_sce, n_dimred = 10, dimred = 'PCA_HVGs', name = "UMAP_1") #BEFORE BATCH CORRECTION
#HARMONY BATCH CORRECTION
set.seed(20398) 
combined_sce <- runUMAP(combined_sce, n_dimred = 10, dimred = 'PCA_HVGs_corr', name = "UMAP_corrected_mouse")#AFTER 

############################################
# CLUSTERING
set.seed(20300)
# Building SNN graph and clustering with Louvain algorithm
sce.g <- buildSNNGraph(combined_sce, k = 30, use.dimred = 'PCA_HVGs_corr')
sce.louvain <- igraph::cluster_louvain(sce.g)$membership
colLabels(combined_sce) <- factor(sce.louvain)
```

#CELL ANNOTATION
```{r}
ref<- ImmGenData()
pred <- SingleR(test=combined_sce, ref=ref, labels=ref$label.main)
tab <- table(Assigned=pred$pruned.labels, Cluster=colLabels(combined_sce))
pheatmap(log2(tab+10), color=colorRampPalette(c("white", "blue"))(101))
```

```{r}
# Annotate cells based on label correspondence
label_annotations <- c(
  '5' = 'DC', 
  '12' = 'Macrophage', '6' = 'Macrophage', '1' = 'Macrophage', '8' = 'Macrophage',
  
  '2' = 'Monocyte',
  '4' = 'T_gamma_delta', '6' = 'T_gamma_delta',
  
  '15' = 'Basophils',
  '13' = 'Eosinophils',
  '17' = 'Eosinophils',
  
  '14' = 'Fibroblast',
  
  '9' = 'B_cell',
  
  '16' = 'Endothelial_cell',
  
  '11' = 'Neutrophil', 
  '3' = 'Neutrophil', 
  '2' = 'Neutrophil', 
  
  '10' = 'Stem_cell',
  
  '4' = 'Gamma_delta_T_cells',
  '7' = 'T_cells'
)
combined_sce$cell_type <- factor(label_annotations[as.character(combined_sce$label)], levels = unique(label_annotations))
```

#QUALITY CONTOL
```{r}
# Retrieving the mitochondrial transcripts and ERCC spike-in transcripts using genomic locations included in
# the row-level annotation for the SingleCellExperiment.
is.mito <- grep("^mt-", rowData(combined_sce)$Symbol)
is.spike <- grepl("^ERCC", rownames(combined_sce))

# Calculate per-cell QC metrics for the total data
df <- perCellQCMetrics(combined_sce, subsets = list(mito = is.mito, ERCC = is.spike))

# Alternatively, add QC metrics to the total_data object
total_data <- addPerCellQC(combined_sce, subsets = list(mito = is.mito, ERCC = is.spike))

# Identifying low-quality cells
# Identifying outliers for various QC metrics using median absolute deviation (MAD)
qc.lib2 <- isOutlier(df$sum, log = TRUE, type = "lower")
qc.nexprs2 <- isOutlier(df$detected, log = TRUE, type = "lower")
qc.spike2 <- isOutlier(df$subsets_ERCC_percent, type = "higher")
qc.mito2 <- isOutlier(df$subsets_mito_percent, type = "higher")
qc.mito_5percent <- df$subsets_mito_percent > 5

# Printing the thresholds for reference
attr(qc.lib2, "thresholds")
attr(qc.nexprs2, "thresholds")
attr(qc.spike2, "thresholds")
attr(qc.mito2, "thresholds")
```

```{r}
# Removing low-quality cells based on QC metrics
discard <- qc.lib2 | qc.nexprs2 | qc.mito_5percent

DataFrame(LibSize=sum(qc.lib2), NExprs=sum(qc.nexprs2), SpikeProp=sum(qc.spike2), MitoProp=sum(qc.mito_5percent), Total=sum(discard))

# Subsetting the total_data object to remove low-quality cells
filtered <- combined_sce[, !discard]
```

``
#EXAMINING GENE-LEVEL EXPESSION METRICS
INSPECTING THE MOST HIGHLY EXPRESSED GENES
```{r}
# EXAMINING GENE-LEVEL EXPRESSION METRICS
# INSPECTING THE MOST HIGHLY EXPRESSED GENES

# Removing genes that are not expressed by any cell
keep_feature <- nexprs(filtered, byrow=TRUE) > 0
filtered <- filtered[keep_feature, ]
dim(filtered)

# Filtering out low-abundance genes
ave.counts <- calculateAverage(filtered)
hist(log10(ave.counts), breaks=100, main="", col="grey80", 
     xlab=expression(Log[10]~"average count"))

demo.keep <- ave.counts >= 0.00001
filtered <- filtered[demo.keep, ]
dim(filtered)

# Examining the number of cells that express each gene
num.cells <- nexprs(filtered, byrow=TRUE)
hist(log10(num.cells), breaks=100, main="", col="grey80", 
     xlab=expression(Log[10]~"number of cells"))

# Further filtering to keep genes expressed in more than 5 cells
to.keep <- num.cells > 5
filtered <- filtered[to.keep, ]
dim(filtered)

combined_sce<- filtered
```



#Saving object annotated
  ##Contains everything 
```{r}
setwd("~/Dropbox/Merieme_Project/CCR2_Paper/scRNA_analysis/Objects")
saveRDS(combined_sce, file = "combined_sce.rds.gz")
```

#WORKING ON NEUTROPHILS
#Subseting on neutrophils
```{r}
sce_Neutro<- combined_sce[, combined_sce$cell_type == "Neutrophil"]
```


#Normalizing, dimensionality reduction, clustering
```{r}
##############################################
#NORMALIZATION
#LIBRARY SIZE NORMALIZATION
set.seed(100)
sce_Neutro<- logNormCounts(sce_Neutro)
#convert to a seurat object if needed
#seurat_obj <- as.Seurat(sce_filtered, counts = "counts", data = "logcounts")

#PER-GENE VARIATION
dec.sce <- modelGeneVar(sce_Neutro)
chosen <- getTopHVGs(dec.sce, prop=1)
str(chosen)

#############################################
#DIMENSIONALITY REDUCTION: PCA Analysis
set.seed(1458847) 
sce_Neutro <- runPCA(sce_Neutro, subset_row = chosen, name = "PCA_HVGs") 
percent.var <- attr(reducedDim(sce_Neutro, 'PCA_HVGs'), 'percentVar')
cat("Percentage of variance explained by top PCs:", percent.var, "\n")

############################################
# RUN HARMONY TO REMOVE BATCH EFFECTS
set.seed(12345)
reducedDim(sce_Neutro, 'PCA_HVGs_corr') <- HarmonyMatrix(reducedDim(sce_Neutro, 'PCA_HVGs'), meta_data = colData(sce_Neutro), vars_use = 'Condition')

############################################
# RUN UMAPs
set.seed(20398) 
sce_Neutro <- runUMAP(sce_Neutro, n_dimred = 10, dimred = 'PCA_HVGs', name = "UMAP_1") #BEFORE BATCH CORRECTION
#HARMONY BATCH CORRECTION
set.seed(20398) 
sce_Neutro <- runUMAP(sce_Neutro, n_dimred = 10, dimred = 'PCA_HVGs_corr', name = "UMAP_corrected_mouse")#AFTER 

############################################
# CLUSTERING
set.seed(20300)
# Building SNN graph and clustering with Louvain algorithm
sce.g <- buildSNNGraph(sce_Neutro, k = 30, use.dimred = 'PCA_HVGs_corr')
sce.louvain <- igraph::cluster_louvain(sce.g)$membership
colLabels(sce_Neutro) <- factor(sce.louvain)
```

#Representing UMAP
```{r}
library(ggplot2)
library(dplyr)

# your labels and palette
labels <- c("1","2","3","4","5","6")
color_palette <- c(
  "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78",
  "#2ca02c", "#98df8a", "#d62728", "#ff9896",
  "#9467bd", "#c5b0d5", "#8c564b", "#c49c94",
  "#e377c2", "#f7b6d2", "#7f7f7f"
)

# extract UMAP and labels
set.seed(20300)
umap_mat <- reducedDim(sce_Neutro, "UMAP_corrected_mouse")
df <- data.frame(
  UMAP1 = umap_mat[,1],
  UMAP2 = umap_mat[,2],
  label = factor(colData(sce_Neutro)$label, levels = labels)
)

# compute centroids
centroids <- df %>%
  group_by(label) %>%
  summarize(
    UMAP1 = mean(UMAP1, na.rm = TRUE),
    UMAP2 = mean(UMAP2, na.rm = TRUE)
  )

# plot
ggplot(df, aes(x = UMAP1, y = UMAP2, color = label)) +
  geom_point(size = 2, alpha = 0.6) +
  geom_text(
    data = centroids,
    aes(label = label),
    color = "black",
    size = 5,
    fontface = "bold"
  ) +
  scale_color_manual(
    values = color_palette,
    breaks = labels,
    name = "Cluster"
  ) +
  theme_classic(base_size = 14) +
  labs(
    title = "UMAP of Neutrophils — cluster centroids",
    x     = "UMAP 1",
    y     = "UMAP 2"
  ) +
  theme(
    legend.position = "right",
    legend.title    = element_text(size = 12),
    legend.text     = element_text(size = 10)
  )

```

#Dectection of Ccr2+ neutrophils
```{r}
# 1. Extract raw UMI counts for Ccr2 from sce_Neutro
raw_counts <- assay(sce_Neutro, "counts")["Ccr2", ]

# 2. Define “Ccr2 detected” as raw_counts ≥ 1 UMI
sce_Neutro$Ccr2_detected <- raw_counts >= 1

# 3. Quick check of how many cells are positive vs. negative
table(sce_Neutro$Ccr2_detected)

# 4. Plot UMAP colored by “Ccr2_detected” (TRUE/FALSE)
set.seed(20300)
plotReducedDim(
  sce_Neutro,
  dimred    = "UMAP_corrected_mouse",
  colour_by = "Ccr2_detected",
  text_by   = "Ccr2_detected"    # optional: adds text labels
)
```

#Subsetting Blood, BM and Aorta
```{r}
#sce_Neutro_all<- sce_Neutro
sce_Neutro<- sce_Neutro[, sce_Neutro$Organ %in% c("Blood", "Bone_marrow", "Aorta")]
```

##compute percent expressed
```{r}
#/ per gene calculate the number of cells per Organ that express it
get_pexpr <- function(data, group, threshold=0, digits=2){
  
  if(ncol(data)!=length(group)) stop("ncol(data) != length(group)")
  if(!is.numeric(threshold) | threshold < 0) stop("threshold must be numeric and > 0")
  
  datar <- (data>threshold) * 1
  a <- base::rowsum(x=t(datar), group=group)
  b <- as.numeric(table(group)[rownames(a)])
  f <- base::round(100*t(apply(a, 2, function(x) x/b)), digits=digits)
  f
}

percent_expressed <- get_pexpr(data = assay(sce_Neutro), group = sce_Neutro$Ccr2_detected)
```

##Subset genes that are expressed by at least 10% of the cells
```{r}
min_expression <- 5
genes_to_use <- rownames(percent_expressed)[apply(percent_expressed, 1, function(row) any(row >= min_expression))]# considering a 10% OVER ALL GROUPS
```


##Creating a new summed object and DGEList object comparing labels
```{r}
sce_Neutro.clean <- sce_Neutro[genes_to_use,]
y <- DGEList(counts(sce_Neutro.clean), samples = colData(sce_Neutro.clean))

# Normalization
y <- calcNormFactors(y)
design <- model.matrix(~0 + label, y$samples)
colnames(design) <- gsub('label', '', colnames(design))
colnames(design) <- paste0("label", colnames(design))
y <- estimateDisp(y, design)

# Fit model
fit <- glmQLFit(y, design, robust = TRUE)
```

# Get DEGs, testing against a fold change
```{r}

contrasts <- makeContrasts(
  label1_vs_label2 = label1 - label2,
  label1_vs_label3 = label1 - label3,
  label1_vs_label4 = label1 - label4,
  label1_vs_label5 = label1 - label5,
  label1_vs_label6 = label1 - label6,
  
  label2_vs_label3 = label2 - label3,
  label2_vs_label4 = label2 - label4,
  label2_vs_label5 = label2 - label5,
  label2_vs_label6 = label2 - label6,
  
  label3_vs_label4 = label3 - label4,
  label3_vs_label5 = label3 - label5,
  label3_vs_label6 = label3 - label6,
  
  label4_vs_label5 = label4 - label5,
  label4_vs_label6 = label4 - label6,

  label5_vs_label6 = label5 - label6,
  
  levels = design
)



# Get DEGs, testing against a fold change:                  
res <- sapply(colnames(contrasts), function(con){
  tt<-topTags(glmTreat(fit,contrast=contrasts[,con], log2(1.5)),n=Inf)$table
  return(data.frame(Gene=rownames(tt), tt))
}, simplify = FALSE)

# Rank the DEGs:
ranked <- RankDEGs(res, delim="_vs_", signif.column="FDR", signif.threshold=0.05,
                   effect.column="logFC", effect.threshold=0, gene.column="Gene",
                   rnk.column="PValue", rnk.method="increasing")

# Create signatures, keeping top 50 signature genes that separate the respective celltype from all other celltypes:
signatures <- CreateGeneSignatures(ranked=ranked, keep.n=5, min.prop=0.8)

# check number of genes:
lengths(signatures)
```


Heatmap
```{r}
# Calculate logCPM values
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# Extract and scale logCPM values for signature genes
logcpmZ <- t(scale(t(logcpm[unique(unlist(signatures)), ])))

# Trim values to within the 5th and 95th percentiles
q_upper <- quantile(logcpmZ, 0.95, na.rm = TRUE)
q_lower <- quantile(logcpmZ, 0.05, na.rm = TRUE)
logcpmZ[logcpmZ > q_upper] <- q_upper
logcpmZ[logcpmZ < q_lower] <- q_lower

# Extract metadata for cell types
Metadata <- data.frame(label = y$samples$label)
rownames(Metadata) <- colnames(logcpmZ)

# Define new cell types and corresponding color palette
labels <- c(
  "1", "2", "3", "4",
  "5", "6"
 )

color_palette <- c(
  "#1f77b4",  # blue
  "#aec7e8",  # light blue
  "#ff7f0e",  # orange
  "#ffbb78",  # light orange
  "#2ca02c",  # green
  "#98df8a",  # light green
  "#d62728",  # red
  "#ff9896",  # light red
  "#9467bd",  # purple
  "#c5b0d5",  # light purple
  "#8c564b",  # brown
  "#c49c94",  # light brown
  "#e377c2",  # pink
  "#f7b6d2",  # light pink
  "#7f7f7f"   # gray
)

# Define custom order for new cell types
custom_order <- c("2", "3", "5", "4", "1", "6")

# Assign specific colors for each cell type
annotation_colors <- list(label = setNames(color_palette, labels))

# Sort metadata based on custom order for cell types
Metadata$label <- factor(Metadata$label, levels = custom_order)
sorted_Metadata <- Metadata[order(Metadata$label), , drop = FALSE]

# Define column order based on sorted metadata
col_order <- rownames(sorted_Metadata)

# Plot heatmap ordered by custom label order with specified label colors
pheatmap(
  mat = logcpmZ[, col_order],
  show_colnames = FALSE, 
  cluster_rows = TRUE, 
  cluster_cols = FALSE, 
  fontsize_row = 12, 
  annotation_col = sorted_Metadata, 
  annotation_colors = annotation_colors,
  color = colorRampPalette(c("#54bebe", "#76c8c8", "#98d1d1", "#badbdb", "#dedad2", "#e4bcad", "#df979e", "#d7658b", "#c80064"))(100)
)
```

##Creating a new summed object and DGEList object comparing CCR2+ and CCR2-
```{r}
sce_Neutro.clean <- sce_Neutro[genes_to_use,]
y <- DGEList(counts(sce_Neutro.clean), samples = colData(sce_Neutro.clean))

# Normalization
y <- calcNormFactors(y)
design <- model.matrix(~0 + Ccr2_detected, y$samples)
colnames(design) <- gsub('label', '', colnames(design))
colnames(design) <- paste0("label", colnames(design))
y <- estimateDisp(y, design)

# Fit model
fit <- glmQLFit(y, design, robust = TRUE)
```


##Get DEGs, testing against a fold change
```{r}
# Updated contrasts with 17 labels as the 18 is too small
contrasts <- makeContrasts(
  labelCCR2high_vs_labelCCR2low = labelCcr2_detectedTRUE - labelCcr2_detectedFALSE,
   levels = design
)


# Get DEGs, testing against a fold change:                  
res <- sapply(colnames(contrasts), function(con){
  tt<-topTags(glmTreat(fit,contrast=contrasts[,con], log2(1.5)),n=Inf)$table
  return(data.frame(Gene=rownames(tt), tt))
}, simplify = FALSE)

# Rank the DEGs:
ranked <- RankDEGs(res, delim="_vs_", signif.column="FDR", signif.threshold=0.05,
                   effect.column="logFC", effect.threshold=0, gene.column="Gene",
                   rnk.column="PValue", rnk.method="increasing")

# Create signatures, keeping top 50 signature genes that separate the respective celltype from all other celltypes:
signatures <- CreateGeneSignatures(ranked=ranked, keep.n=50, min.prop=0.8)

# check number of genes:
lengths(signatures)
```


```{r}
data<- as.data.frame(res$labelCCR2high_vs_labelCCR2low)
```

##Plotting Volcano
```{r}
# Load required libraries
library(ggplot2)
library(ggrepel)

# Assume your DEG results are in a data frame called 'data'
# Ensure that gene names are stored in a column "Gene" (or add them if missing)
data$Gene <- rownames(data)

# Exclude the gene "Nfya"
data <- subset(data, Gene != "Ccr2")

# Compute the -log10(FDR) for the y-axis
data$negLogFDR <- -log10(data$FDR)

# Identify the top 5 genes with the highest logFC and the top 5 with the lowest logFC
top5_high <- data[order(data$logFC, decreasing = TRUE), ][1:10, ]
top5_low <- data[order(data$logFC, decreasing = FALSE), ][1:10, ]
label_genes <- rbind(top5_high, top5_low)

# Create flags for labeling and coloring
data$label_gene <- ifelse(data$Gene %in% label_genes$Gene, data$Gene, "")
data$colorGroup <- ifelse(data$Gene %in% label_genes$Gene, "highlight", "normal")

# Define adjustable axis limits (change these values as needed)
x_limits <- c(-5, 5)  # x-axis limits
y_limits <- c(0, 20)  # y-axis limits

# Define dot size and transparency
dot_size <- 2.5     # Adjust dot size as needed
dot_alpha <- 0.5  # Adjust dot transparency (alpha) as needed

# Create the volcano plot using ggplot2 and geom_label_repel for labels in a white box with a black border
volcano_plot <- ggplot(data, aes(x = logFC, y = negLogFDR, color = colorGroup)) +
  geom_point(size = dot_size, alpha = dot_alpha) +
  scale_color_manual(values = c("normal" = "grey", "highlight" = "red2")) +
  geom_label_repel(aes(label = label_gene),
                   size = 5,            # Larger label text
                   fill = "white",      # White background for the label
                   color = "black",     # Black text and border
                   box.padding = 0.5,
                   point.padding = 0.5,
                   label.size = 0.5,    # Border thickness
                   max.overlaps = Inf) +
  labs(
    title = "Volcano",
    x = "Log2FC",
    y = "-Log10(FDR)"
  ) +
  scale_x_continuous(limits = x_limits) +
  scale_y_continuous(limits = y_limits) +
  theme_classic() +
  theme(
    axis.text.x = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16)
  )

# Display the plot
print(volcano_plot)
```

##Signature analysis
Creating Gene sets
```{r}

df<- as.data.frame(Gene_Sets_Complete_last)

# Create a list to store the GeneSet objects
gene_sets <- list()

# Iterate through each column in the data frame
for (col_name in colnames(df)) {
  # Remove NA values and ensure uniqueness
  gene_values <- unique(na.omit(df[[col_name]]))
  
  # Create a GeneSet object for the column
  gene_set <- GeneSet(gene_values, setName = col_name)
  
  # Store the GeneSet object in the list
  gene_sets[[col_name]] <- gene_set
}

# Combine all GeneSet objects into a GeneSetCollection
New_gene_signatures <- GeneSetCollection(gene_sets)

```

```{r}
# Define the maximum allowed size for a gene set
max_genes <- 1500

# Trim each gene set to max_genes if necessary
trimmed_gene_sets <- GeneSetCollection(
  lapply(New_gene_signatures, function(gene_set) {
    trimmed_genes <- head(geneIds(gene_set), max_genes)  # Keep only the first max_genes
    GeneSet(trimmed_genes, setName = setName(gene_set))
  })
)

# Run ESCAPE with the trimmed gene sets
sce_Neutro <- runEscape(
    sce_Neutro, 
    gene.sets = trimmed_gene_sets, 
    method = "UCell",
    groups = 1000, 
    cores = 4, 
    maxRank = 5000, 
    min.size = NULL, 
    new.assay.name = "Gene_Set_Collections"
)
```

``
#Adding signatures to columns
```{r}
#Extracting data 
Gene_Set_Collections_columns<- as.data.frame(t(sce_Neutro@int_colData@listData[["altExps"]]@listData[["Gene_Set_Collections"]]@se@assays@data@listData[["Gene_Set_Collections"]]))

sce_columns<-as.data.frame(colData(sce_Neutro))#extract from colData
coldata_new<- cbind(sce_columns, Gene_Set_Collections_columns)#join colData
coldata_new<- DataFrame(coldata_new)##ojo con esto

colData(sce_Neutro)<- coldata_new #adding colData
```

#Analysis of significance in transcriptional signatures
```{r}
#––– Load required libraries
library(dplyr)
library(tidyr)
library(plotthis)    # for BoxPlot()
library(ggplot2)
library(rstatix)     # for t_test()
library(ggpubr)      # for stat_pvalue_manual()

#––– 1) Extract metadata and define signature-score columns
meta <- as.data.frame(colData(sce_Neutro))

# Make sure you have at least 84 columns before subsetting 8:84
if (ncol(meta) < 84) {
  stop("`meta` has only ", ncol(meta), " columns; cannot select 8:84")
}
score_cols <- colnames(meta)[8:84]

#––– 2) Ensure Ccr2_detected is a two-level factor
meta <- meta %>%
  mutate(Ccr2_detected = factor(Ccr2_detected, levels = c(FALSE, TRUE)))

#––– 3) Prepare output container and directory
all_ttests <- tibble()
output_dir <- "~/Dropbox/Merieme_Project/CCR2_Paper/scRNA_analysis/Signatures"
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

#––– 4) Loop over each signature score and run unpaired t-test
for (sc in score_cols) {
  # a) Subset to non-missing values
  df <- meta %>%
    filter(!is.na(.data[[sc]])) %>%
    select(Ccr2_detected, value = !!sym(sc))
  
  # b) Skip if only one CCR2 level or too few cells
  if (n_distinct(df$Ccr2_detected) < 2) next
  if (nrow(df) < 10) next
  
  # c) Run unpaired Welch’s t-test
  stat.test <- df %>%
    t_test(value ~ Ccr2_detected, var.equal = FALSE)
  
  # d) Precompute y-position for annotation from the original df
  y.pos <- max(df$value, na.rm = TRUE) * 1.05
  
  stat.test <- stat.test %>%
    mutate(
      y.position = y.pos,
      label      = paste0("p = ", signif(p, 2))
    )
  
  # e) Store results
  all_ttests <- bind_rows(
    all_ttests,
    stat.test %>% mutate(score = sc)
  )
  
  # f) Build the box+violin plot
  p <- BoxPlot(
    data       = df,
    x          = "Ccr2_detected",
    y          = "value",
    add_violin = TRUE
  ) +
    labs(
      title = sc,
      x     = "CCR2 detected",
      y     = sc
    ) +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.2))) +
    theme_classic(base_size = 14) +
    stat_pvalue_manual(
      stat.test,
      label      = "label",
      xmin       = "group1",
      xmax       = "group2",
      y.position = "y.position",
      tip.length = 0.02,
      bracket.size = 0.3,
      inherit.aes  = FALSE
    )
  
  # g) Save the plot
  ggsave(
    filename = file.path(output_dir, paste0("TTEST_CCR2_", sc, ".png")),
    plot     = p,
    width    = 8,
    height   = 6,
    units    = "in",
    dpi      = 300
  )
}

#––– 5) Write out all t-test results
write.csv(
  all_ttests,
  file.path(output_dir, "Signature_comparison_CCR2.csv"),
  row.names = FALSE
)

#######

# …after your existing loop has populated `all_ttests` …

library(dplyr)

# 1) Add BH-adjusted p-values and simple significance stars
all_ttests <- all_ttests %>%
  mutate(
    p.adj = p.adjust(p, method = "BH"),
    signif = case_when(
      p.adj < 0.001 ~ "***",
      p.adj < 0.01  ~ "**",
      p.adj < 0.05  ~ "*",
      TRUE          ~ "ns"
    )
  )

# 2) Write out the FDR‐corrected table
write.csv(
  all_ttests,
  file.path(output_dir, "Signature_comparison_CCR2_withFDR.csv"),
  row.names = FALSE
)
```

#Plotting Lollipop plot
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# 1) Define your categories map as before
cat_map <- tribble(
  ~score, ~Category,
  # Transcription factors
  "CEBPa", "Transcription factor",
  "CEBPb", "Transcription factor",
  "Relb",  "Transcription factor",
  "Klf6",  "Transcription factor",
  "JunB",  "Transcription factor",
  "Chd1",  "Transcription factor",
  "Irf2",  "Transcription factor",
  "Irf3",  "Transcription factor",
  "Sox5",  "Transcription factor",
  "Ep300", "Transcription factor",
  # Metabolism
  "Oxidative.phosphorylation..GO.000619.",     "Metabolism",
  "pentose.phosphate.shunt..GO.0006098.",      "Metabolism",
  # Neutrophil function
  "Phagocytosis..GO.0006911.",      "Neutrophil function",
  "ROS.production..GO.1903409.",    "Neutrophil function",
  "NETosis",                        "Neutrophil function",
  "Complement.activation..GO.0006956.", "Neutrophil function",
  "Mdsc", "Neutrophil function"
)

# 2) Pull out and reshape your data
df_fc <- meta %>%
  select(Ccr2_detected, all_of(cat_map$score)) %>%
  pivot_longer(-Ccr2_detected, names_to="score", values_to="value") %>%
  filter(!is.na(value)) %>%
  group_by(score, Ccr2_detected) %>%
  summarize(mean_val = mean(value), .groups="drop") %>%
  pivot_wider(names_from=Ccr2_detected,
              values_from=mean_val,
              names_prefix="CCR2_") %>%
  # compute fold change (TRUE / FALSE)
  mutate(
    fold_change = CCR2_TRUE / CCR2_FALSE
  ) %>%
  # attach categories
  inner_join(cat_map, by="score") %>%
  # order factor levels: categories then score order
  mutate(
    Category = factor(Category,
      levels = c("Transcription factor","Metabolism","Neutrophil function")
    ),
    score = factor(score, levels = rev(cat_map$score))
  )

# 3) Plot: baseline at 1, line to fold_change, point at fold_change
ggplot(df_fc) +
  geom_vline(xintercept = 1, linetype="dashed", color="gray70") +
  geom_segment(aes(
    x = 1, xend = fold_change,
    y = score, yend = score
  ), color = "gray80") +
  geom_point(aes(x = fold_change, y = score),
             color = "palegreen4", size = 6) +
  facet_grid(Category ~ ., scales="free_y", space="free") +
  scale_x_continuous(
    name = "Fold change (CCR2+ / CCR2–)",
    breaks = scales::pretty_breaks(5)
  ) +
  labs(
    y = NULL,
    title = "Fold‐change in signature score: CCR2+ vs CCR2–"
  ) +
  theme_classic(base_size = 14) +
  theme(
    strip.text.y    = element_text(angle = 0, size = 12, face = "bold"),
    axis.text.y     = element_text(size = 16),
    panel.spacing.y = unit(0.5, "lines")
  )


```