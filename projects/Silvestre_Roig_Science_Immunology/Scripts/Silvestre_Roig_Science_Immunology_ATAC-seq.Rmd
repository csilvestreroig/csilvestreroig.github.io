---
title: "Silvestre_Roig et al. Science Immunology: ATAC-seq data; bulk RNA-seq GMPs"
output: html_notebook
---
Creator: Carlos Silvestre Roig

##ATAC-seq 



#Packages
```{r}
pkgs <- c(
  "BiocParallel",
  "BSgenome.Mmusculus.UCSC.mm10",
  "chromVAR",
  "ComplexHeatmap",
  "cowplot",
  "csaw",
  "data.table",
  "DESeq2",
  "doParallel",
  "edgeR",
  "hexbin",
  "magrittr",
  "magick",
  "matrixStats",
  "memes",
  "motifmatchr",
  "openxlsx",
  "patchwork",
  "TFBSTools",
  "tidyverse",
  "SingleCellExperiment",
  "GenomicFeatures"
)

# BiocManager::install(pkgs)
invisible(lapply(pkgs, library, character.only = TRUE))

theme_set(theme_bw(base_size=12))

# parallel things
mc_workers <- floor(parallel::detectCores() - 2)

if(mc_workers < 1) mc_workers <- 1

Sys.setenv(BIOCPARALLEL_WORKER_NUMBER = mc_workers)
doParallel::registerDoParallel(cores = mc_workers)

bpparam <- BiocParallel::DoparParam(RNGseed=1)
BiocParallel::register(bpparam)

options(future.globals.maxSize = 8000 * 1024^2)

if("RhpcBLASctl" %in% rownames(installed.packages())){
  
  RhpcBLASctl::omp_set_num_threads(1)
  RhpcBLASctl::blas_set_num_threads(1)
  
}
```


```{r}
setwd("~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/EXPERIMENTS/NS-128_Atac_seq/data_and_code_maturation_thingy")
```

#ATAC-SEQ AND RNA ANALYSIS
#Setup
```{r}
library(dplyr)

# Read (keep original names as-is)
df <- read.delim("GSE109467_readCount_renamed_geneName.txt.gz", check.names = FALSE)

# Force the first column to be called `gene_id` no matter what its current name is
colnames(df)[1] <- "gene_id"

# Build a stable gene label and clean Ensembl version suffixes
df <- df %>%
  mutate(
    gene_id = sub("\\..*$", "", gene_id),  # drop .version
    gene    = ifelse(!is.na(gene_name) & gene_name != "",
                     paste(gene_name, gene_id, sep = "_"),
                     gene_id)
  )

# Pick count/sample columns (everything except known annotation columns)
annot_cols <- c("gene_id","gene_name","Chr","Start","End","Strand","Length","gene")
sample_cols <- setdiff(names(df), annot_cols)

# Keep gene label + counts, set rownames, drop helper column
z <- df[, c("gene", sample_cols)]
rownames(z) <- make.unique(z$gene)
z$gene <- NULL

```

# Evrard dataset
## Load counts
```{r load_data}

# Load counts from GEO
z <- read.delim("GSE109467_readCount_renamed_geneName.txt.gz") %>%
  rename(gene_id = X) %>%
  mutate(gene_id = gsub("\\..*", "", gene_id),
         gene = paste(gene_name, gene_id, sep = "_"))
z <- z[,8:ncol(z)]
rownames(z) <- z$gene
z$gene <- NULL

# Write as SingleCellExperiment in a list so things are collected in a single place
evrard <- list()
evrard$sce_all <- SingleCellExperiment(assays = list(counts = z))
rowData(evrard$sce_all)$gene_name <- gsub("_.*", "", rownames(evrard$sce_all))
evrard$sce_all$label <- gsub("_.*", "", colnames(evrard$sce_all))

# Normalize using edgeR
evrard$sce_all$lib.size <- colSums(assay(evrard$sce_all))

evrard$prefilter_all <- filterByExpr(assay(evrard$sce_all), group = evrard$sce_all$label)
evrard$sce_all$norm.factors <- as.numeric(calcNormFactors(assay(evrard$sce_all[evrard$prefilter_all,])))
evrard$sce_all$effective.lib.size <- evrard$sce_all$lib.size * evrard$sce_all$norm.factors

# Define celltypes based on their unusual labels
evrard$sce_all$celltype <- data.frame(colData(evrard$sce_all)) %>%
  mutate(celltype = case_when(
    label == "GMP" ~ "GMP",
    label == "PN" ~ "preNeu",
    label == "EN" ~ "imNeu",
    label == "LN" ~ "matNeu",
    label == "BN5" ~ "blood_Neu5",
    label == "BN13" ~ "blood_Neu13",
    TRUE ~ "remove"
  )) %>% pull(celltype)

evrard$sce_all$celltype <- factor(evrard$sce_all$celltype, c("GMP", "preNeu", "imNeu", "matNeu", "blood_Neu5", "blood_Neu13"))
evrard$sce_all$celltype

evrard$sce_all$tissue <- factor(if_else(grepl("blood", evrard$sce_all$celltype), "blood", "bm"), c("bm", "blood"))
evrard$sce_all$tissue

```

## Testing

Two tests: 
a) maturation genes as those with changes within BM
b) function genes as those different matNeu BM vs matNeu Bld
```{r}

run_tests <- c("maturation", "functional")

de_results <- bplapply(run_tests, function(x){
  
  if(x == "maturation"){
    
    sce <- evrard$sce_all[,evrard$sce_all$tissue %in% "bm"]
    colData(sce) <- droplevels.data.frame(colData(sce))
    design <- model.matrix(~celltype, colData(sce))
    keep <- filterByExpr(assay(sce), design = design) 
    
  }
  
  if(x == "functional"){
    
    sce <- evrard$sce_all[,evrard$sce_all$celltype %in% c("matNeu", "blood_Neu5", "blood_Neu13")]
    colData(sce) <- droplevels.data.frame(colData(sce))
    design <- model.matrix(~0 + celltype, colData(sce))
    keep <- filterByExpr(assay(sce), design = design) 
    
  }
    
  sce <- sce[keep,]
  disp <- edgeR::estimateDisp(y = assay(sce), lib.size = sce$effective.lib.size, design = design)
  fit <- edgeR::glmQLFit(y = assay(sce), lib.size = sce$effective.lib.size, dispersion = disp$trended.dispersion, design = design)
  
  if(x == "maturation"){
    
    fit <- glmQLFTest(fit, coef = 4:ncol(design))
    
  }
  
  if(x == "functional"){
    
    # matNeu-BM vs the average of the two blood samples
    contrast_use <- rep(0, ncol(design))
    contrast_use[colnames(design) == "celltypematNeu"] <- 1
    w <- which(!colnames(design) == "celltypematNeu")
    contrast_use[w] <- -1 / length(w)
    fit <- glmQLFTest(fit, contrast = contrast_use)
    
  }
  
  
  tt <- topTags(fit, n = Inf)$table %>% rownames_to_column("Gene")
  tt$test <- x
  return(tt)
  
})

names(de_results) <- run_tests

degs_maturation <- de_results$maturation %>%
  filter(FDR < 0.005) %>%
  pull(Gene)

degs_functional <- de_results$functional %>%
  filter(FDR < 0.05) %>%
  pull(Gene)

length(degs_maturation)
length(degs_functional)

# Functional signature is a large subset of the maturation signature
length(intersect(degs_functional, degs_maturation))

lcpm <- edgeR::cpm(assay(evrard$sce_all), lib.size = evrard$sce_all$effective.lib.size, log = TRUE)[degs_maturation,]

scaled <- t(scale(t(lcpm)))
cluster_rows <- hclust(dist(scaled), "ward.D2")
scaled_trim <- scaled
scaled_trim[scaled_trim > quantile(scaled, .95)] <- quantile(scaled, .95)
scaled_trim[scaled_trim < quantile(scaled, .05)] <- quantile(scaled, .05)


######################## HEATMAP ############################
#Extended Figure 9A

library(ComplexHeatmap)
library(circlize)

## 1) Build a continuous color function from your 9-color palette
pal100 <- colorRampPalette(c(
  "#54bebe", "#76c8c8", "#98d1d1", "#badbdb",
  "#dedad2", "#e4bcad", "#df979e", "#d7658b", "#c80064"
))(100)

rng <- range(scaled_trim, na.rm = TRUE)
col_fun <- circlize::colorRamp2(
  seq(rng[1], rng[2], length.out = length(pal100)),
  pal100
)

## 2) Make a column split vector that is 1:1 with the matrix columns
# (Assumes columns of scaled_trim correspond to columns in evrard$sce_all)
stopifnot(all(colnames(scaled_trim) %in% colnames(evrard$sce_all)))

col_split <- evrard$sce_all$celltype[ match(colnames(scaled_trim), colnames(evrard$sce_all)) ]
# Optional: set a desired order for the split strips
# col_split <- factor(col_split, levels = c("LSK","CMP","GMP","PreN","imNeu","Neutro"))

## 3) Draw heatmap with fully named arguments (prevents “argument X matches multiple formal arguments”)
ht <- ComplexHeatmap::Heatmap(
  matrix            = scaled_trim,
  name              = "z",
  col               = col_fun,
  cluster_rows      = cluster_rows,
  cluster_columns   = FALSE,
  column_split      = col_split,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  use_raster        = FALSE,
  row_split         = 4
)

draw(ht) 

#############################Plotting Extended Figure 9B######################
rs <- rowsum(t(scaled), group = evrard$sce_all$celltype)
rmeans <- t(rs / as.numeric(table(evrard$sce_all$celltype)[rownames(rs)]))

rod <- row_order(ht)

l <- lapply(1:length(rod), function(x){
  
  gns <- rownames(scaled_trim)[rod[[x]]]
  r <- rmeans[gns,]
  co <- colMeans(r)
  data.frame(celltype = names(co), value = as.numeric(co), cluster = paste0("C", x)) %>%
    mutate(celltype=factor(celltype, celltype),
           celltype_idx = as.numeric(celltype))
  
}) %>% bind_rows()

library(dplyr)
library(ggplot2)
library(ggh4x)



ll <- l %>%
  mutate(cluster = factor(cluster, levels = c("C1","C2", "C3", "C4"))) %>%
  ggplot(aes(x = celltype, y = value, group = cluster, color = cluster)) +
  geom_line() +
  geom_point(size = 4.8) +  # bigger points
  scale_color_manual(values = c(C1 = "#C96159", C2 = "#41933B", C3 = "#5FA9D9", C4 = "#BF62CB")) +
  theme_classic() +
  theme(
    axis.text.x  = element_text(angle = 45, hjust = 1, size = 14),
    axis.text.y  = element_text(size = 14),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.title.y = element_text(size = 16, face = "bold"),
    legend.position = "none"
  ) +
  facet_wrap2(
    ~ cluster,
    labeller = labeller(cluster = c(C1 = "Cluster 1", C2 = "Cluster 2", C3 = "Cluster 3", C4 = "Cluster 4")),
    strip = strip_themed(
      background_x = list(
        element_rect(fill = "#C96159", colour = NA),
        element_rect(fill = "#41933B", colour = NA), 
        element_rect(fill = "#5FA9D9", colour = NA),
        element_rect(fill = "#BF62CB", colour = NA)
      ),
      text_x = list(
        element_text(colour = "white", face = "bold", size = 18),  # label size 18
        element_text(colour = "white", face = "bold", size = 18)
      )
    )
  )



ll

names(rod) <- paste0("rnaCluster", 1:length(rod))
rna_evrard_clusters <- lapply(names(rod), function(x){
  data.frame(cluster = x, gene = rownames(scaled_trim)[rod[[x]]])
  
}) %>% bind_rows()
```


# Integrate with ATAC-seq

## DE
```{r}
# This is the ATAC-seq object from the 01 script that contains an offset matrix for normalization
setwd("~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/EXPERIMENTS/NS-128_Atac_seq/data_and_code_maturation_thingy")
sce_atac <- as(readRDS("se_atac.rds"), "SingleCellExperiment")


# Some sanitation of the peak coordinates so rowRanges() will be a GRanges object with peak coordinates
tmp <- strsplit(names(rowRanges(sce_atac)), ":|-")

rowRanges(sce_atac) <- matrix(unlist(tmp), byrow = TRUE, ncol = 3) %>%
  data.frame %>%
  setNames(c("chr", "start", "end")) %>%
  makeGRangesFromDataFrame(df = ., starts.in.df.are.0based = FALSE)

rm(tmp)

rownames(sce_atac) <- paste0("Peak_", 1:nrow(sce_atac))

# Now test for differential accessability
d <- data.frame(colData(sce_atac)) %>%
  dplyr::select(celltype, tissue) %>% 
  unique

d$tissue <- factor(d$tissue, c("SP", "Bld", "BM"))

loop_by <- lapply(levels(d$celltype), function(x){
  
  dd <- droplevels.data.frame(d[d$celltype == x,])
  tissues <- combn(levels(dd$tissue), 2)
  celltypes <- rep(x, ncol(tissues))
  m <- matrix(
    data = c(celltypes, t(tissues)),
    byrow = FALSE, ncol = 3
  )
  
  data.frame(m)
  
}) %>% bind_rows() %>% setNames(c("celltypes", "tissue1", "tissue2"))

loop_by[nrow(loop_by) + 1,] <- c("PreN_and_imNeu", "SP", "BM")
loop_by$name <- apply(loop_by, 1, paste, collapse = "_")

loop_by

atac_de_res_list <- bplapply(loop_by$name, function(x){
  
  lo <- loop_by[loop_by$name %in% x,]
  use_celltypes <- strsplit(lo$celltypes, "_and_")[[1]]
  
  sce <- sce_atac[,sce_atac$celltype %in% use_celltypes & sce_atac$tissue %in% c(lo$tissue1, lo$tissue2)]
  colData(sce) <- droplevels.data.frame(colData(sce))
  sce$tissue <- relevel(sce$tissue, ref = lo$tissue2)  
  
  len_celltypes <- length(levels(sce$celltype))
  
  if(len_celltypes == 1){
    
    design <- model.matrix(~tissue, colData(sce))
    
  } else {
    
    design <- model.matrix(~tissue + celltype, colData(sce))
    
  }
  
  if(!is.fullrank(design)) {
    
    warning("Design not full rank")
    return(NULL)
    
  }
  
  # The offsets come from the loess-based normalization in the 01_*.rmd script that we used already for all other ATAC analysis.
  # It replaces the "normal" normalization code.
  disp <- edgeR::estimateDisp(y = assay(sce, "counts"), design = design, offset = assay(sce, "offsets"))
  fit <- edgeR::glmQLFit(y = assay(sce, "counts"), offset = assay(sce, "offsets"), dispersion = disp$trended.dispersion, design = design)
  
  use_coef <- paste0("tissue", lo$tissue1)
  fit <- glmTreat(glmfit = fit, coef = use_coef, lfc = log2(1.1))

  tt <- topTags(fit, n = Inf, sort.by = "none")$table %>% 
    mutate(Peak = rownames(.)) %>%
    relocate("Peak")
  
  tt$comparison <- lo$name
  
  rrg <- rowRanges(sce)[,0]
  mcols(rrg) <- tt
  rrg
  
})

names(atac_de_res_list) <- loop_by$name

# Thats the number of significant (TRUE) or not (FALSE) ATAC-seq peaks globally per comparison
lapply(atac_de_res_list, function(x) summary(x$FDR<0.05)[c("TRUE", "FALSE")])

```

## Annotation
Prepare a mapping of which peaks lie within 50kb of each gene promoters
```{r}

# Now create the annotations, so which ATAC-seq peaks belongs to which of the RNA signature genes
# For this, load a GTF to get transcripts per gene 
gtf_rds <- "gtf.rds"

if(file.exists(gtf_rds)){
  
  gtf <- readRDS(gtf_rds)
  
} else {
  
  gtf <- rtracklayer::import("https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.annotation.gtf.gz")
  
}

gtf <- gtf[gtf$type == "transcript"]
gtf$gene_id <- gsub("\\..*", "", gtf$gene_id)
gtf$gene <- paste(gtf$gene_name, gtf$gene_id, sep = "_")

# Get the coordinates of the promoters of the signature genes. Output is a GRanges object
# wit the genomic coordinates and a column "signature"
suppressPackageStartupMessages({
  library(GenomicRanges)
  library(GenomicFeatures)
})

# 1) pick the gene metadata column from your GTF
gene_col <- intersect(c("gene", "gene_name", "gene_id", "symbol"), names(mcols(gtf)))
if (length(gene_col) == 0) stop("No gene column found in 'gtf' metadata.")
gene_col <- gene_col[1]

# 2) ensure ATAC ranges are GRanges
atac_gr <- if (inherits(sce_atac, "RangedSummarizedExperiment")) rowRanges(sce_atac) else as(sce_atac, "GRanges")

# 3) build a list of GRanges (one per cluster), already filtered to those overlapping ATAC
gr_list <- lapply(unique(rna_evrard_clusters$cluster), function(xn) {
  current_genes <- rna_evrard_clusters$gene[rna_evrard_clusters$cluster == xn]

  r <- gtf[mcols(gtf)[[gene_col]] %in% current_genes]

  # promoters at TSS (width 1)
  p <- promoters(r, upstream = 1, downstream = 0)

  # carry gene id/name and signature
  mcols(p)$gene <- mcols(r)[[gene_col]]
  mcols(p)$signature <- xn

  # deduplicate by genomic position + gene (avoid multi-transcript duplicates)
  p <- p[!duplicated(paste0(seqnames(p), ":", start(p), ":", strand(p), ":", mcols(p)$gene))]

  # keep only promoters overlapping ATAC peaks
  keep <- overlapsAny(p, atac_gr, ignore.strand = TRUE)
  p[keep]  # returns an empty GRanges if none, not NULL
})

# 4) be safe: drop any non-GRanges (shouldn't happen, but prevents do.call() errors)
gr_list <- Filter(function(x) methods::is(x, "GRanges"), gr_list)

# 5) combine
rna_clusters_ranges <- if (length(gr_list) == 0) GRanges() else do.call(c, unname(gr_list))

rna_clusters_ranges
#########################

# Now extend these promoter positions by 25kb each direction
window_total <- 50000L
rna_clusters_ranges_extended <- GenomicRanges::resize(
  x = rna_clusters_ranges, width = window_total, fix = "center"
)

#Set directory
setwd("~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/EXPERIMENTS/NS-128_Atac_seq/data_and_code_maturation_thingy")

granule <- openxlsx::read.xlsx(
  "Borregaards_JLB_2013_granule_proteome_list.xlsx", check.names = FALSE
) %>%
  reshape2::melt(measure.vars = colnames(.)) %>%
  setNames(c("granule", "gene_name")) %>%
  filter(!is.na(gene_name))

# Remove the few duplicates  
granule <- granule[!granule$gene_name %in% granule$gene_name[duplicated(granule$gene_name)],]

#-------------------------------------------------------------

# This is now-gene-centered annotation. For each of the Evrard signature genes
# we extend the promoters by 50kb and check whether it overlaps a significant ATAC-seq
# peak per comparison.

gene_centered_annotations <- bplapply(names(atac_de_res_list), function(x){
    
  atac <- atac_de_res_list[[x]]
  atac$direction <- data.frame(atac) %>%
    mutate(direction = case_when(FDR < 0.05 & logFC > 0 ~ "more accessible",
                                 FDR < 0.05 & logFC < 0 ~ "less accessible",
                                 TRUE ~ "ns")
    ) %>%
    pull(direction)
  
  atac <- atac[!atac$direction == "ns"]
  
  olap <- as.data.frame(findOverlaps(rna_clusters_ranges_extended, atac))
  olap$gene <- rna_clusters_ranges_extended$gene[olap$queryHits]
  olap$signature <- rna_clusters_ranges_extended$signature[olap$queryHits]
  olap$direction <- atac$direction[olap$subjectHits]
  olap$peak <- atac$Peak[olap$subjectHits]
  
  olap_unique <- olap %>%
    distinct(gene, peak, direction, signature)
  
  olap_annot <- olap_unique %>%
    group_by(gene, direction, signature) %>%
    summarize(peak = paste(unique(peak), collapse = ","))
  
  #olap_annot$n_peaks <- unlist(lapply(olap_annot$peak, function(x) sum(grepl("\\,", x)) + 1))
  
  olap_annot <- olap_annot %>%
    relocate(gene, signature, peak) %>%
    mutate(
      comparison = x, 
      gene_name = gsub("_.*", "", gene),
      maturation_signature = if_else(gene %in% degs_maturation, TRUE, FALSE),
      functional_signature = if_else(gene %in% degs_maturation, TRUE, FALSE),
      both_signature = if_else(maturation_signature & functional_signature, TRUE, FALSE)
    )
  
  olap_final <- left_join(x = olap_annot, y = granule, by = "gene_name") %>%
    dplyr::select(-gene_name)
  
  olap_final
  
}) %>% bind_rows()

gene_centered_annotations$granule <- as.character(gene_centered_annotations$granule)
gene_centered_annotations$granule[is.na(gene_centered_annotations$granule)] <- "NA"
head(gene_centered_annotations)

write.table(gene_centered_annotations, "gene_centered_annotations.tsv", col.names = TRUE, row.names = FALSE, quote = FALSE,
            sep = "\t")
```

Above table has for each RNA signature gene the signature membership (that is the clusters 1-4, the plot is called `ll`),
the ID of the assigned ATAC-seq peak, the number of assigned ATAC-seq peaks per direction, the differential analysis comparison,
whether the gene is part of the maturation and/or functional signature and to which of the granule annotations it intersects.

#Plotting open/close peaks associated with the maturation genes from Evrard et al.
```{r}
library(dplyr)
library(ggplot2)
library(stringr)
library(tidyr)
library(ggh4x)

## clusters to keep (now 4)
sig_keep <- c("rnaCluster1","rnaCluster2","rnaCluster3","rnaCluster4")

## stage order & labels
stages <- c("GMP_SP_BM","PreN_SP_BM","imNeu_SP_BM")
stage_labels <- c("GMP","preNEU","immNEU")

## cluster strip colors (your request)
cluster_strip_cols <- c(
  "Cluster 1" = "#C96159",
  "Cluster 2" = "#41933B",
  "Cluster 3" = "#5FA9D9",
  "Cluster 4" = "#BF62CB"
)

## Open/Closed colors (unchanged)
state_cols <- c(Open = "#88a0dc", Closed = "#ed968c")

## build summarized data
df_counts2 <- gene_centered_annotations %>%
  filter(
    maturation_signature == TRUE,
    comparison %in% stages,
    direction %in% c("more accessible","less accessible")
  ) %>%
  mutate(signature = str_trim(signature)) %>%
  separate_rows(signature, sep = ",") %>%
  filter(signature %in% sig_keep) %>%
  mutate(
    state = if_else(direction == "more accessible", "Open", "Closed"),
    comparison = factor(comparison, levels = stages, labels = stage_labels),
    signature_label = recode(
      signature,
      "rnaCluster1" = "Cluster 1",
      "rnaCluster2" = "Cluster 2",
      "rnaCluster3" = "Cluster 3",
      "rnaCluster4" = "Cluster 4"
    ),
    # lock facet order
    signature_label = factor(signature_label, levels = c("Cluster 1","Cluster 2","Cluster 3","Cluster 4"))
  ) %>%
  group_by(signature_label, comparison, state) %>%
  summarise(n_peaks = n_distinct(peak), .groups = "drop")

## build ggh4x strip backgrounds in facet order
strip_list <- lapply(levels(df_counts2$signature_label), function(lbl) {
  element_rect(fill = cluster_strip_cols[[lbl]], color = NA)
})

## plot
p <- ggplot(df_counts2, aes(x = comparison, y = n_peaks, group = state, color = state)) +
  geom_line(linewidth = 1) +
  geom_point(size = 4.5) +
  geom_text(aes(label = n_peaks),
            vjust = -0.6, size = 4, show.legend = FALSE, color = "black") +
  scale_color_manual(values = state_cols, name = NULL) +
  labs(x = "", y = "Number of peaks") +
  ggh4x::facet_wrap2(
    ~ signature_label, ncol = 2,  # set ncol = 4 if you want all in one row
    strip = ggh4x::strip_themed(
      background_x = strip_list,
      text_x = replicate(length(strip_list),
                         element_text(color = "white", face = "bold", size = 18),
                         simplify = FALSE)
    )
  ) +
  theme_classic() +
  theme(
    axis.title.x = element_text(family = "Arial", size = 16),
    axis.title.y = element_text(family = "Arial", size = 16),
    axis.text.x  = element_text(family = "Arial", size = 14),
    axis.text.y  = element_text(family = "Arial", size = 14),
    legend.text  = element_text(family = "Arial", size = 12),
    strip.text.x = element_text(margin = margin(t = 6, b = 6))
  )

p

```

#ANALYSIS OF BULK RNA-SEQ 
##Loading data
```{r}
# List files in the archive
files_in_archive <- untar("rawcounttables.tar.bz2", list = TRUE)
print(files_in_archive)

# Extract files to a new directory called "rawcounttables"
untar("rawcounttables.tar.bz2", exdir = "rawcounttables")

dir<- "~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/Proteomics and transcriptomics/TRANSCRIPTOME/RNAseq/AMD3100 model/RNAseq_stem_cells"
```

##Reading counts
```{r}
# Load required package
library(DESeq2)

dir<- "~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/Proteomics and transcriptomics/TRANSCRIPTOME/RNAseq/AMD3100 model/RNAseq_stem_cells/rawcounttables/star"

# Read the STAR counts file using file.path to build the full path
star_data <- read.table(file.path(dir, "GENE.tsv"), header = TRUE, sep = "\t")

# 2. Extract columns that contain read counts (columns ending with ".reads")
read_cols <- grep("\\.reads$", colnames(star_data), value = TRUE)
count_matrix <- as.matrix(star_data[, read_cols])
rownames(count_matrix) <- paste(star_data$symbol, star_data$geneid, sep = "_")

# Remove the ".reads" suffix to clean up sample names
sample_names <- sub("\\.reads$", "", read_cols)
colnames(count_matrix) <- sample_names

# Create a gene annotation data frame from star_data
gene_annotation <- star_data[, c("geneid", "symbol", "type")]
rownames(gene_annotation) <- gene_annotation$geneid

# 3. Define sample metadata based on your mapping information
sample_info <- data.frame(
  sample = c("lane1_AGGCAG", "lane1_CTCTCT", "lane2_AGGCAG", "lane2_CTCTCT",
             "lane1_CGTACT", "lane1_TAGGCA", "lane2_CGTACT", "lane2_TAGGCA",
             "lane1_GGACTC", "lane1_TAAGGC", "lane2_GGACTC", "lane2_TAAGGC",
             "lane1_CGAGGC", "lane1_TCCTGA", "lane2_CGAGGC", "lane2_TCCTGA",
             "lane3_AGGCAG", "lane3_CTCTCT", "lane4_AGGCAG", "lane4_CTCTCT",
             "lane3_CGTACT", "lane3_TAGGCA", "lane4_CGTACT", "lane4_TAGGCA",
             "lane3_GGACTC", "lane3_TAAGGC", "lane4_GGACTC", "lane4_TAAGGC",
             "lane3_CGAGGC", "lane3_TCCTGA", "lane4_CGAGGC", "lane4_TCCTGA"),
  condition = c(rep("BM_CMP", 4), rep("BM_GMP", 4), rep("BM_LSK", 4), rep("BM_MEP", 4),
                rep("SP_CMP", 4), rep("SP_GMP", 4), rep("SP_LSK", 4), rep("SP_MEP", 4)),
  replicate = rep(1:4, times = 8),
  reads_millions = c(36.64, 39.50, 38.46, 31.94,    # BM_CMP
                     39.46, 29.38, 25.02, 35.89,    # BM_GMP
                     40.34, 34.24, 34.35, 42.91,    # BM_LSK
                     33.40, 31.61, 42.48, 41.32,    # BM_MEP
                     43.55, 33.65, 30.25, 29.41,    # SP_CMP
                     36.03, 31.78, 27.59, 32.69,    # SP_GMP
                     36.86, 39.54, 38.35, 36.98,    # SP_LSK
                     30.87, 29.22, 35.02, 32.25)    # SP_MEP
)
rownames(sample_info) <- sample_info$sample


# Apply the corrected annotations you provided:
fix_map <- c(
  "lane4_TAGGCA" = "SP_CMP",
  "lane4_CGAGGC" = "SP_GMP",
  "lane4_CTCTCT" = "SP_MEP"
)

ix <- rownames(sample_info) %in% names(fix_map)
sample_info$condition[ix] <- unname(fix_map[rownames(sample_info)[ix]])


# Inspect the sample metadata
print(sample_info)
```

##PCA analysis
```{r}
# Load required packages
library(DESeq2)
library(pheatmap)
library(ggplot2)

# (Assuming that count_matrix and sample_info have been defined as in your previous code)
# For reference, count_matrix was created from star_data (STAR counts file) and sample_info from the mapping info.

# Check the order before reordering
all(colnames(count_matrix) == rownames(sample_info))
# If this returns FALSE, reorder sample_info:
sample_info <- sample_info[colnames(count_matrix), ]

# Now you can create the DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = count_matrix,
                              colData = sample_info,
                              design = ~ condition)

# ====================
# Add gene symbol information to the DESeqDataSet
# ====================
# 'star_data' contains the original gene annotation with columns 'geneid' and 'symbol'
# We match the rownames of dds (which are the ENSEMBL IDs) to star_data$geneid and add the symbol.
rowData(dds)$symbol <- star_data$symbol[match(rownames(dds), star_data$geneid)]
# Optionally, add other annotation columns if desired:
# rowData(dds)$type <- star_data$type[match(rownames(dds), star_data$geneid)]

# ====================
# Quality Control and Transformation
# ====================

# 1. Preliminary Filtering: Remove genes with very low counts (e.g., total counts <= 10)
dds <- dds[rowSums(counts(dds)) > 10, ]

# 2. Apply a variance stabilizing transformation (VST)
# This transformation helps to stabilize the variance across the range of counts.
vsd <- vst(dds, blind = FALSE)

# 3. Visualize Sample-to-Sample Distances via a Heatmap
# Calculate distances between samples using the VST-transformed counts.
sampleDists <- dist(t(assay(vsd)))
# Plot the heatmap of sample distances.
pheatmap(as.matrix(sampleDists),
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         main = "Sample Distance Matrix (VST)")

# 4. Generate a PCA Plot for QC
# Plotting PCA to visualize how samples cluster by condition.
pcaData <- plotPCA(vsd, intgroup = "condition", returnData = TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color = condition)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  ggtitle("PCA of RNAseq Data (VST-transformed)") +
  theme_minimal()
```

##Creating DEGlist
```{r}
library(edgeR)

# 1. Create a DGEList using your bulk count matrix and sample metadata
y <- DGEList(counts = count_matrix, samples = sample_info)

# 1.1 Add gene annotation from the STAR file.
# Here, we use the 'star_data' data frame that was read earlier.
# We assume rownames(count_matrix) correspond to star_data$geneid.
#y$genes <- star_data[match(rownames(y$counts), star_data$geneid), c("geneid", "symbol", "type")]

# 2. Filter lowly expressed genes using filterByExpr
design <- model.matrix(~0 + condition, data = y$samples)
colnames(design) <- gsub('condition', 'label', colnames(design))

keep <- filterByExpr(y, design = design)
y <- y[keep, , keep.lib.sizes = FALSE]

# 3. Normalize the data (TMM normalization)
y <- calcNormFactors(y)

# 4. Create a design matrix based on the 'condition' variable in your metadata
#    Rename the columns so they include the prefix "label" (e.g., labelBM_CMP, etc.)

# 5. Estimate dispersion
y <- estimateDisp(y, design)

# 6. Fit the quasi-likelihood model using glmQLFit
fit <- glmQLFit(y, design, robust = TRUE)
```

##Plotting rnaCluster signatures as heatmap
###rnaCluster1 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster1_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c(
  "0610030E20Rik","1700037C18Rik","1700047M11Rik","2310044K18Rik","2610035D17Rik",
  "4732465J04Rik","4933439K11Rik","6430548M08Rik","6530402F18Rik","9830107B12Rik",
  "A130014A01Rik","A330023F24Rik","A530064D06Rik","Aatk","Abcd2","Abr","Acpp","Actn1",
  "Adam19","Adam8","Ago2","Alox5ap","Amer2","Ampd3","Angel2","Anxa11","Arhgap25",
  "Arhgap27","Arhgef3","Arrb2","Asprv1","Atg3","Atp11a","Atxn10","AU019990",
  "B230208H11Rik","B2m","B4galt5","Bach1","Bag6","Baz2b","Bin3","Bmpr1a","Btg1",
  "C5ar1","C5ar2","Card10","Carns1","Cass4","Ccdc126","Ccdc63","Ccdc88b","Ccrl2",
  "Cd300a","Cdc42ep4","Cdk11b","Ceacam10","Cep19","Cers6","Cfap43","Cflar","Chac1",
  "Chd7","Chil1","Chil5","Chrm3","Cib2","Clec5a","Cln5","Cmtm6","Cmtr1","Coq4",
  "Creb3","Cst3","Ctsh","Cxcr2","D17H6S53E","D8Ertd738e","Dedd2","Dennd1b","Dennd4a",
  "Dgat1","Dhdds","Dhx38","Dhx40","Dmxl2","Dock5","Dstyk","Dusp1","Dvl1","E4f1",
  "Eapp","Efcab14","Efhd2","Egln3","Egr1","Eif2ak3","Elmsan1","Entpd3","F5",
  "F630028O10Rik","Fam160a2","Fam222b","Fosl2","Fpr2","Furin","G0s2","Gadd45a",
  "Gadd45g","Galc","Gale","Gdap2","Gid8","Gm10382","Gm10463","Gm11714","Gm14703",
  "Gm16091","Gm16894","Gm17552","Gm20406","Gm26535","Gm26588","Gm28809","Gm38379",
  "Gm5533","Gmeb1","Gmip","Gnai3","Gpank1","Gpr132","Gramd1b","Gsr","H2-Aa","H2-Ab1",
  "H2-Eb1","Hdc","Hexa","Hook3","Hp","Hsh2d","Ifitm1","Ifitm2","Ifitm6","Igf1r",
  "Igf2r","Il16","Il1f9","Il1r2","Inpp4a","Inpp5a","Itm2b","Itpk1","Itpripl2",
  "Jund","Kat5","Kif23","Kif3b","Klf5","Klhdc4","Lamtor3","Lasp1","Lbr","Lcp1",
  "Lfng","Lgals8","Lrg1","Lrrk2","Lypla2","Lyz2","Map2k4","Map3k14","Map3k9","Mapk14",
  "Max","Mbd2","Mbnl2","Mboat7","Mbp","Mettl9","Mfsd9","Mgll","Mmp25","Mon2","Mtmr12",
  "Mxd1","Myh9","N4bp1","Nadk","Ncf1","Ncf4","Nek6","Neurl3","Nfe2l2","Nfkb1","Nisch",
  "Nt5c2","Nt5e","Ntng2","Nudt7","Oas2","Oas3","Oat","Orai2","Orm2","Pabpc1l","Padi4",
  "Pag1","Pak2","Panct2","Pbx1","Pgd","Pglyrp1","Phactr2","Phlda1","Phospho1","Pigx",
  "Pik3cb","Pik3r5","Pilra","Pilrb1","Pilrb2","Pip4k2a","Pirb","Pithd1","Plaur","Plbd1",
  "Plcl2","Plek","Plekhm1","Pnpla1","Pnpla7","Polr1a","Ppp1ca","Ppp2r5a","Pqlc2",
  "Prickle3","Prkch","Psmb9","Ptpn23","Qsox1","Rab11fip1","Rab43","Rab7","Rab8a","Rad9a",
  "Rapgef2","Rassf5","Rbfa","Rbm18","Retnlg","Rgs2","Rin3","Riok3","Rlf","Rmdn1",
  "Rnf169","Rnf19a","Rnf216","Rogdi","Rps27","Rps6ka4","Rsph1","Rsrc2","Rufy4",
  "S100a11","S100a3","S100a6","S100a8","S100a9","Samsn1","Sema4f","Sema6b","Sgk1","Sin3b",
  "Slc16a3","Slc22a15","Slc27a4","Slc2a3","Slc35a5","Slc35e1","Slc41a3","Slc6a6","Slco4c1",
  "Slfn1","Smad3","Smim14","Smim4","Son","Sorl1","Spg11","Srgn","St3gal4","St3gal5",
  "Stab1","Stard3","Stat1","Stat3","Stfa2l1","Stk38","Stx11","Stx17","Syk","Syp","Szt2",
  "Taf12","Tap1","Tbc1d14","Tcf20","Tcp11l2","Tex15","Tinagl1","Tirap","Tln1","Tmem123",
  "Tmem131","Tmem154","Tmem202","Tmem40","Tmsb4x","Tnfsf13b","Tnrc6b","Tns1","Tpcn2","Trem1",
  "Trem3","Treml4","Trib1","Trim12c","Trim25","Trim30b","Trp53inp2","Trub2","Tubb6","Txnl4b",
  "Ubc","Ugp2","Upf2","Upp1","Vps26b","Vps54","Wdfy4","Wfdc21","Wsb1","Xkr5","Xpa","Zbtb39",
  "Zdhhc18","Zdhhc7","Zfp36l2","Zkscan6","Zswim4","Zxdc"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```

###rnaCluster2 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster2_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c(
  "1700123O20Rik", "1810006J02Rik", "1810055G02Rik", "2010016I18Rik", 
"4930438A08Rik", "Abca13", "Actr3", "Adpgk", "Adtrp", "Agpat2", 
"Ankrd46", "Anxa1", "Anxa7", "Arfgef1", "Bcar3", "Bnip2", "Camp", 
"Cd177", "Cebpe", "Ckap4", "Cldn1", "Clec4a2", "Cops8", "Cpne3", 
"Cyb561a3", "Cyb5r4", "Cyfip2", "Cystm1", "Degs1", "Dennd2d", 
"Dnajb14", "Eea1", "Ets1", "Exoc1", "Exoc2", "Fam71b", "Fbxo10", 
"Fcnb", "Glyr1", "Golim4", "Gpi1", "Gramd2", "Hc", "Heatr6", 
"Hlcs", "Hmgn2", "Hsd11b1", "Ighv1-56", "Itgb2l", "Larp4b", "Ldha", 
"Lin28a", "Lipg", "Ltf", "Map6", "Mapk7", "Med8", "Mgat1", "Mpnd", 
"Mppe1", "Mpzl1", "Mreg", "Msrb2", "Ncam1", "Ndufv3", "Ngp", 
"Nhsl2", "Npepps", "Nt5c3", "Olfml2b", "Orm1", "Paqr7", "Pcmt1", 
"Pfkfb3", "Pgp", "Plin3", "Ppp1cb", "Ptger4", "Rab13", "Rasa2", 
"Rps6kc1", "Sema3g", "Sftpb", "Sh3tc1", "Slc25a24", "Slc31a2", 
"Slco4a1", "Smg9", "Sptlc1", "Sri", "Stard8", "Stradb", "Stxbp5", 
"Syne1", "Tbc1d2", "Tbc1d8", "Thap4", "Ticam1", "Tmem159", "Tmem45a2", 
"Tom1", "Trabd", "Trak2", "Tshr", "Ubr2", "Usp46", "Vps26a", 
"Zfp414"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```

###rnaCluster3 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster3_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c(
 "Abcc4", "Acad8", "Acadl", "Ado", "Akr7a5", "Aldh9a1", "Arv1", 
"Aurka", "Calm3", "Ccdc61", "Cd81", "Cdadc1", "Cdc25a", "Cenpf", 
"Cep41", "Cherp", "Cnep1r1", "Coq5", "Cox10", "Cptp", "Cstf1", 
"Ctnnd1", "Dera", "Dph7", "Dtnbp1", "Dus2", "Egfl7", "Enkd1", 
"Fbxo27", "Fem1a", "Glod4", "Gm16286", "Gm26692", "H2-DMb1", 
"Hibadh", "Hibch", "Hmgxb4", "Hnrnpa3", "Ica1", "Idh3a", "Kdsr", 
"Kif17", "Kntc1", "Lig3", "Lmo1", "Lrrc58", "Map3k4", "Map4k1", 
"Med19", "Mki67", "Mmgt2", "Mogat2", "Mpp7", "Mrpl15", "Mrpl45", 
"Mrrf", "Naglu", "Ncapd3", "Ncoa7", "Ncor2", "Nedd4", "Nucb2", 
"Pask", "Pcnt", "Pds5a", "Pdss2", "Pelp1", "Pgam1", "Pigu", "Ppp1r7", 
"Prc1", "Prpf4", "Ptcd3", "Pxylp1", "Rcbtb2", "Rfc1", "Rnf26", 
"Rngtt", "Rpl3", "Rpn1", "Rprd1b", "Rrp12", "Rtkn2", "Serpinb1a", 
"Sh2d5", "Slc17a9", "Slc35b2", "Slc39a10", "Slc39a11", "Snhg17", 
"Stmn1", "Syngr1", "Tacc2", "Tfap4", "Timm21", "Tmco1", "Tmem138", 
"Tmem216", "Tmx2", "Tnfrsf26", "Tprkb", "Tssc4", "Ttc13", "Tti1", 
"Tubgcp6", "Ubash3a", "Ube2g2", "Ubxn8", "Uggt1", "Uhrf1", "Uhrf1bp1", 
"Usp2", "Usp39", "Vdac2", "Vkorc1l1", "Wdr4", "Zfp282", "Zkscan8", 
"Zmpste24"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```

###rnaCluster4 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster4_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c("Atp13a1", "Bckdhb", "Dcps", "Dhtkd1", "Dph5", "Ergic1", "Fbxl6", 
"Foxred1", "Gart", "Gm16897", "Gpc3", "Gtf3a", "H2-Ob", "Heatr3", 
"Hsp90ab1", "Mrfap1", "Mri1", "Nt5dc2", "Park7", "Poli", "Psmb8", 
"Rps10", "Skp1a", "Slc14a1", "Slc52a2", "Snhg6", "Sufu", "Tbc1d4", 
"Thyn1", "Txnl4a", "Wdr3", "Zfp61", "Zfp94"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```


#ANALYSIS IN SCRNA-SEQ 
```{r}
filename <- file.choose() #I choose sce_scvelo from Velocity folder
sce_scvelo <- readRDS(filename)
```

##Analysis 4 clusters
```{r}
# --- packages ---
library(SingleCellExperiment)
library(escape)         # runEscape / UCell
library(dplyr)
library(tidyr)
library(ggplot2)

# --- 1) Define your gene sets (as provided) ---
rnaCluster1_ALL <- c("0610030E20Rik","1700037C18Rik","1700047M11Rik","2310044K18Rik",
"2610035D17Rik","4732465J04Rik","4933439K11Rik","6430548M08Rik","6530402F18Rik","9830107B12Rik",
"A130014A01Rik","A330023F24Rik","A530064D06Rik","Aatk","Abcd2","Abr","Acpp","Actn1","Adam19",
"Adam8","Ago2","Alox5ap","Amer2","Ampd3","Angel2","Anxa11","Arhgap25","Arhgap27","Arhgef3",
"Arrb2","Asprv1","Atg3","Atp11a","Atxn10","AU019990","B230208H11Rik","B2m","B4galt5","Bach1",
"Bag6","Baz2b","Bin3","Bmpr1a","Btg1","C5ar1","C5ar2","Card10","Carns1","Cass4","Ccdc126",
"Ccdc63","Ccdc88b","Ccrl2","Cd300a","Cdc42ep4","Cdk11b","Ceacam10","Cep19","Cers6","Cfap43",
"Cflar","Chac1","Chd7","Chil1","Chil5","Chrm3","Cib2","Clec5a","Cln5","Cmtm6","Cmtr1","Coq4",
"Creb3","Cst3","Ctsh","Cxcr2","D17H6S53E","D8Ertd738e","Dedd2","Dennd1b","Dennd4a","Dgat1",
"Dhdds","Dhx38","Dhx40","Dmxl2","Dock5","Dstyk","Dusp1","Dvl1","E4f1","Eapp","Efcab14","Efhd2",
"Egln3","Egr1","Eif2ak3","Elmsan1","Entpd3","F5","F630028O10Rik","Fam160a2","Fam222b","Fosl2",
"Fpr2","Furin","G0s2","Gadd45a","Gadd45g","Galc","Gale","Gdap2","Gid8","Gm10382","Gm10463",
"Gm11714","Gm14703","Gm16091","Gm16894","Gm17552","Gm20406","Gm26535","Gm26588","Gm28809",
"Gm38379","Gm5533","Gmeb1","Gmip","Gnai3","Gpank1","Gpr132","Gramd1b","Gsr","H2-Aa","H2-Ab1",
"H2-Eb1","Hdc","Hexa","Hook3","Hp","Hsh2d","Ifitm1","Ifitm2","Ifitm6","Igf1r","Igf2r","Il16",
"Il1f9","Il1r2","Inpp4a","Inpp5a","Itm2b","Itpk1","Itpripl2","Jund","Kat5","Kif23","Kif3b",
"Klf5","Klhdc4","Lamtor3","Lasp1","Lbr","Lcp1","Lfng","Lgals8","Lrg1","Lrrk2","Lypla2","Lyz2",
"Map2k4","Map3k14","Map3k9","Mapk14","Max","Mbd2","Mbnl2","Mboat7","Mbp","Mettl9","Mfsd9",
"Mgll","Mmp25","Mon2","Mtmr12","Mxd1","Myh9","N4bp1","Nadk","Ncf1","Ncf4","Nek6","Neurl3",
"Nfe2l2","Nfkb1","Nisch","Nt5c2","Nt5e","Ntng2","Nudt7","Oas2","Oas3","Oat","Orai2","Orm2",
"Pabpc1l","Padi4","Pag1","Pak2","Panct2","Pbx1","Pgd","Pglyrp1","Phactr2","Phlda1","Phospho1",
"Pigx","Pik3cb","Pik3r5","Pilra","Pilrb1","Pilrb2","Pip4k2a","Pirb","Pithd1","Plaur","Plbd1",
"Plcl2","Plek","Plekhm1","Pnpla1","Pnpla7","Polr1a","Ppp1ca","Ppp2r5a","Pqlc2","Prickle3",
"Prkch","Psmb9","Ptpn23","Qsox1","Rab11fip1","Rab43","Rab7","Rab8a","Rad9a","Rapgef2","Rassf5",
"Rbfa","Rbm18","Retnlg","Rgs2","Rin3","Riok3","Rlf","Rmdn1","Rnf169","Rnf19a","Rnf216","Rogdi",
"Rps27","Rps6ka4","Rsph1","Rsrc2","Rufy4","S100a11","S100a3","S100a6","S100a8","S100a9",
"Samsn1","Sema4f","Sema6b","Sgk1","Sin3b","Slc16a3","Slc22a15","Slc27a4","Slc2a3","Slc35a5",
"Slc35e1","Slc41a3","Slc6a6","Slco4c1","Slfn1","Smad3","Smim14","Smim4","Son","Sorl1","Spg11",
"Srgn","St3gal4","St3gal5","Stab1","Stard3","Stat1","Stat3","Stfa2l1","Stk38","Stx11","Stx17",
"Syk","Syp","Szt2","Taf12","Tap1","Tbc1d14","Tcf20","Tcp11l2","Tex15","Tinagl1","Tirap","Tln1",
"Tmem123","Tmem131","Tmem154","Tmem202","Tmem40","Tmsb4x","Tnfsf13b","Tnrc6b","Tns1","Tpcn2",
"Trem1","Trem3","Treml4","Trib1","Trim12c","Trim25","Trim30b","Trp53inp2","Trub2","Tubb6",
"Txnl4b","Ubc","Ugp2","Upf2","Upp1","Vps26b","Vps54","Wdfy4","Wfdc21","Wsb1","Xkr5","Xpa",
"Zbtb39","Zdhhc18","Zdhhc7","Zfp36l2","Zkscan6","Zswim4","Zxdc")

rnaCluster2_ALL <- c("1700123O20Rik","1810006J02Rik","1810055G02Rik","2010016I18Rik",
"4930438A08Rik","Abca13","Actr3","Adpgk","Adtrp","Agpat2","Ankrd46","Anxa1","Anxa7",
"Arfgef1","Bcar3","Bnip2","Camp","Cd177","Cebpe","Ckap4","Cldn1","Clec4a2","Cops8",
"Cpne3","Cyb561a3","Cyb5r4","Cyfip2","Cystm1","Degs1","Dennd2d","Dnajb14","Eea1","Ets1",
"Exoc1","Exoc2","Fam71b","Fbxo10","Fcnb","Glyr1","Golim4","Gpi1","Gramd2","Hc","Heatr6",
"Hlcs","Hmgn2","Hsd11b1","Ighv1-56","Itgb2l","Larp4b","Ldha","Lin28a","Lipg","Ltf","Map6",
"Mapk7","Med8","Mgat1","Mpnd","Mppe1","Mpzl1","Mreg","Msrb2","Ncam1","Ndufv3","Ngp","Nhsl2",
"Npepps","Nt5c3","Olfml2b","Orm1","Paqr7","Pcmt1","Pfkfb3","Pgp","Plin3","Ppp1cb","Ptger4",
"Rab13","Rasa2","Rps6kc1","Sema3g","Sftpb","Sh3tc1","Slc25a24","Slc31a2","Slco4a1","Smg9",
"Sptlc1","Sri","Stard8","Stradb","Stxbp5","Syne1","Tbc1d2","Tbc1d8","Thap4","Ticam1","Tmem159",
"Tmem45a2","Tom1","Trabd","Trak2","Tshr","Ubr2","Usp46","Vps26a","Zfp414")

rnaCluster3_ALL <- c("Abcc4","Acad8","Acadl","Ado","Akr7a5","Aldh9a1","Arv1","Aurka","Calm3",
"Ccdc61","Cd81","Cdadc1","Cdc25a","Cenpf","Cep41","Cherp","Cnep1r1","Coq5","Cox10","Cptp",
"Cstf1","Ctnnd1","Dera","Dph7","Dtnbp1","Dus2","Egfl7","Enkd1","Fbxo27","Fem1a","Glod4",
"Gm16286","Gm26692","H2-DMb1","Hibadh","Hibch","Hmgxb4","Hnrnpa3","Ica1","Idh3a","Kdsr",
"Kif17","Kntc1","Lig3","Lmo1","Lrrc58","Map3k4","Map4k1","Med19","Mki67","Mmgt2","Mogat2",
"Mpp7","Mrpl15","Mrpl45","Mrrf","Naglu","Ncapd3","Ncoa7","Ncor2","Nedd4","Nucb2","Pask","Pcnt",
"Pds5a","Pdss2","Pelp1","Pgam1","Pigu","Ppp1r7","Prc1","Prpf4","Ptcd3","Pxylp1","Rcbtb2",
"Rfc1","Rnf26","Rngtt","Rpl3","Rpn1","Rprd1b","Rrp12","Rtkn2","Serpinb1a","Sh2d5","Slc17a9",
"Slc35b2","Slc39a10","Slc39a11","Snhg17","Stmn1","Syngr1","Tacc2","Tfap4","Timm21","Tmco1",
"Tmem138","Tmem216","Tmx2","Tnfrsf26","Tprkb","Tssc4","Ttc13","Tti1","Tubgcp6","Ubash3a",
"Ube2g2","Ubxn8","Uggt1","Uhrf1","Uhrf1bp1","Usp2","Usp39","Vdac2","Vkorc1l1","Wdr4","Zfp282",
"Zkscan8","Zmpste24")

rnaCluster4_ALL <- c("Atp13a1","Bckdhb","Dcps","Dhtkd1","Dph5","Ergic1","Fbxl6","Foxred1",
"Gart","Gm16897","Gpc3","Gtf3a","H2-Ob","Heatr3","Hsp90ab1","Mrfap1","Mri1","Nt5dc2","Park7",
"Poli","Psmb8","Rps10","Skp1a","Slc14a1","Slc52a2","Snhg6","Sufu","Tbc1d4","Thyn1","Txnl4a",
"Wdr3","Zfp61","Zfp94")

gene_sets <- list(
  rnaCluster1 = unique(rnaCluster1_ALL),
  rnaCluster2 = unique(rnaCluster2_ALL),
  rnaCluster3 = unique(rnaCluster3_ALL),
  rnaCluster4 = unique(rnaCluster4_ALL)
)

# --- 2) Harmonize with your SCE rownames and drop tiny sets ---
# Escape expects symbols in rownames(sce_scvelo) (usually logcounts). 
present <- rownames(sce_scvelo)
gene_sets_filtered <- lapply(gene_sets, function(gs) intersect(gs, present))

# keep only sets with at least 5 genes present (tweakable)
min_size <- 5
gene_sets_filtered <- gene_sets_filtered[vapply(gene_sets_filtered, length, 1L) >= min_size]

message("Gene set sizes (present in object):")
print(vapply(gene_sets_filtered, length, 1L))

# --- 3) Run ESCAPE with UCell scoring ---
# Choose the assay used for scoring; if you have 'logcounts', ESCAPE will use it by default.
# new.assay.name will store the signature layer; scores are also accessible in colData.
sce_scvelo <- runEscape(
  sce_scvelo,
  gene.sets      = gene_sets_filtered,
  method         = "UCell",
  groups         = 1000,
  cores          = 2,
  maxRank        = 3000,
  min.size       = NULL,             # using our pre-filter above
  new.assay.name = "RNAcluster_signatures"
)
```


```{r}

# ---------- 1) Helper: copy scores from an altExp into colData ----------
add_scores_from_altexp <- function(sce, alt_name, assay_name = NULL, prefix = NULL) {
  stopifnot(alt_name %in% altExpNames(sce))
  ae <- altExp(sce, alt_name)

  # choose assay (prefer "UCell" if available)
  if (is.null(assay_name)) {
    assay_name <- if ("UCell" %in% assayNames(ae)) "UCell" else assayNames(ae)[1]
  }
  mat <- assay(ae, assay_name)     # rows = gene sets (signatures), cols = cells

  # transpose so rows = cells, cols = signatures
  df <- as.data.frame(t(mat))
  if (is.null(prefix)) prefix <- alt_name
  colnames(df) <- paste0(prefix, ".", make.names(rownames(mat)))

  # align to sce column order
  df <- df[colnames(sce), , drop = FALSE]

  colData(sce) <- cbind(colData(sce), S4Vectors::DataFrame(df))
  sce
}

# ---------- 2) Choose which altExp contains the RNA-cluster scores ----------
# EDIT this if needed; below tries to auto-detect a sensible one.
altn <- altExpNames(sce_scvelo)
cand <- altn[grepl("RNA|cluster|signat|ATAC|escape|UCell", altn, ignore.case = TRUE)]
ALTEXP_NAME <- if (length(cand)) cand[1] else altn[1]

# Pull scores into colData (prefers UCell assay if present)
sce_scvelo <- add_scores_from_altexp(sce_scvelo, alt_name = ALTEXP_NAME, assay_name = NULL, prefix = "RNAclust")

# ---------- 3) Prepare plotting data (0–0.15 pseudotime, BM vs Spleen) ----------
# We expect row/term names like rnaCluster1..rnaCluster4 in the altExp.
# After copying, columns became "RNAclust.<signature>"
all_cols <- colnames(colData(sce_scvelo))
wanted <- paste0("RNAclust.", c("rnaCluster1","rnaCluster2","rnaCluster3","rnaCluster4"))
keep_cols <- intersect(all_cols, wanted)
if (length(keep_cols) == 0) stop("Could not find any of: ", paste(wanted, collapse = ", "),
                                 " in colData(sce_scvelo). Check altExp contents.")

meta <- as.data.frame(colData(sce_scvelo))

df_plot <- as.data.frame(colData(sce_scvelo)) %>%
  dplyr::mutate(Organ = as.character(Organ)) %>%
  dplyr::filter(
    Organ %in% c("Bone Marrow", "Spleen"),
    !is.na(velocity_pseudotime),
    velocity_pseudotime >= 0
  ) %>%
  dplyr::select(velocity_pseudotime, Organ, dplyr::all_of(keep_cols)) %>%
  tidyr::pivot_longer(
    cols = dplyr::all_of(keep_cols),
    names_to = "Signature",
    values_to = "Score"
  ) %>%
  dplyr::mutate(
    Signature = sub("^RNAclust\\.", "", Signature),
    Signature = factor(Signature, levels = c("rnaCluster1","rnaCluster2","rnaCluster3","rnaCluster4")),
    Organ     = factor(Organ, levels = c("Bone Marrow","Spleen"))
  )


# ---------- 4) Plot ----------
#spleen until 0.15 (cut) and BM until 0.25
# Define pseudotime ranges for each organ
caps <- c("Bone Marrow" = 0.25, "Spleen" = 0.15)

# 3) Fit LOESS within observed range ∩ organ cap, then predict on that grid
smooth_df <- df_plot %>%
  group_by(Signature, Organ) %>%
  group_modify(~{
    dat <- .x %>%
      arrange(velocity_pseudotime) %>%
      # also cap the TRAINING data to the organ-specific max to avoid extrapolation
      dplyr::filter(velocity_pseudotime <= caps[as.character(.y$Organ)])

    if (nrow(dat) < 5) {
      return(tibble(velocity_pseudotime = numeric(0), fit = numeric(0), se = numeric(0)))
    }

    xmin <- max(0, min(dat$velocity_pseudotime, na.rm = TRUE))
    xmax <- min(caps[as.character(.y$Organ)], max(dat$velocity_pseudotime, na.rm = TRUE))
    if (!is.finite(xmin) || !is.finite(xmax) || xmax <= xmin) {
      return(tibble(velocity_pseudotime = numeric(0), fit = numeric(0), se = numeric(0)))
    }

    xs  <- seq(xmin, xmax, length.out = 200)
    fit <- loess(Score ~ velocity_pseudotime, data = dat, span = 0.6)
    pr  <- predict(fit, newdata = data.frame(velocity_pseudotime = xs), se = TRUE)

    keep <- !(is.na(pr$fit) | is.na(pr$se.fit))
    tibble(
      velocity_pseudotime = xs[keep],
      fit = as.numeric(pr$fit)[keep],
      se  = as.numeric(pr$se.fit)[keep]
    )
  }) %>%
  mutate(
    lo = fit - 1.96 * se,
    hi = fit + 1.96 * se
  ) %>%
  ungroup()

# 4) Plot — organ-colored CI + line; x-axis fixed; SP stops at 0.15, BM can extend to 0.25
ggplot(smooth_df, aes(x = velocity_pseudotime)) +
  geom_ribbon(aes(ymin = lo, ymax = hi, fill = Organ), alpha = 0.35, colour = NA) +
  geom_line(aes(y = fit, colour = Organ), linewidth = 1.2, na.rm = TRUE) +
  geom_vline(xintercept = 0.15, linetype = "dashed", linewidth = 0.6, color = "gray30") +
  scale_color_manual(values = c("Bone Marrow" = "#ADD8E6", "Spleen" = "#c969a1")) +
  scale_fill_manual(values = c("Bone Marrow" = "#ADD8E6", "Spleen" = "#c969a1")) +
  scale_x_continuous(limits = c(0, 0.25)) +
  labs(
    x = "Velocity pseudotime",
    y = "Signature score",
    title = "RNAcluster signature trends across pseudotime"
  ) +
  facet_wrap(~ Signature, ncol = 2, scales = "free_y") +
  theme_classic(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    strip.text = element_text( face = "bold", size = 14),
    legend.title = element_blank()
  )

```

##Plotting  maturation markers: Cxcr2, Cd101
```{r}
library(SingleCellExperiment)
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
library(tibble)

# ----------------------------
# SETTINGS
# ----------------------------
genes <- c("Cxcr2","Cd101")        # genes of interest
bm_col <- "#ADD8E6"
sp_col <- "#c969a1"

# Pick an expression assay (prefer 'logcounts' if present)
assay_name <- if ("logcounts" %in% assayNames(sce_scvelo)) "logcounts" else assayNames(sce_scvelo)[1]

# Keep only genes present
genes_found <- genes[genes %in% rownames(sce_scvelo)]
if (length(genes_found) == 0) stop("None of the requested genes are in 'sce_scvelo' rownames.")

# ----------------------------
# LONG DATA: expression + metadata
# ----------------------------
expr_mat <- as.matrix(assay(sce_scvelo, assay_name)[genes_found, , drop = FALSE])
meta     <- as.data.frame(colData(sce_scvelo))

df_long <- expr_mat %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Gene") %>%
  tidyr::pivot_longer(-Gene, names_to = "Cell", values_to = "Expr") %>%
  dplyr::left_join(
    meta %>%
      tibble::rownames_to_column("Cell") %>%
      dplyr::select(Cell, Organ, velocity_pseudotime),
    by = "Cell"
  ) %>%
  dplyr::mutate(
    Organ = as.character(Organ),
    Gene  = factor(Gene, levels = genes)  # keep input order
  ) %>%
  dplyr::filter(
    Organ %in% c("Bone Marrow","Spleen"),
    !is.na(velocity_pseudotime),
    velocity_pseudotime >= 0, velocity_pseudotime <= 0.25  # keep full BM span; Spleen will be trimmed in prediction
  )

# ----------------------------
# LOESS fits with ORGAN-SPECIFIC x-ranges
# ----------------------------
x_ranges <- list(
  "Bone Marrow" = seq(0, 0.25, length.out = 250),
  "Spleen"      = seq(0, 0.15, length.out = 150)
)

smooth_df <- df_long %>%
  dplyr::group_by(Gene, Organ) %>%
  dplyr::group_modify(~{
    dat <- .x %>% arrange(velocity_pseudotime)
    if (nrow(dat) < 5) {
      message("⚠️ Skipping ", unique(.y$Gene), " / ", unique(.y$Organ), " (too few points)")
      xs <- x_ranges[[as.character(.y$Organ)]]
      return(tibble(velocity_pseudotime = xs, fit = NA_real_, se = NA_real_))
    }
    fit <- loess(Expr ~ velocity_pseudotime, data = dat, span = 0.6)
    xs  <- x_ranges[[as.character(.y$Organ)]]
    pr  <- predict(fit, newdata = data.frame(velocity_pseudotime = xs), se = TRUE)
    tibble(velocity_pseudotime = xs, fit = pr$fit, se = pr$se.fit)
  }) %>%
  dplyr::mutate(
    lo = fit - 1.96 * se,
    hi = fit + 1.96 * se
  ) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(
    Organ = factor(Organ, levels = c("Bone Marrow","Spleen"))
  )

# ----------------------------
# PLOT (smooth lines + shaded CI; BM to 0.25, SP to 0.15; vertical line at 0.15)
# ----------------------------
ggplot(smooth_df, aes(x = velocity_pseudotime, color = Organ, fill = Organ)) +
  geom_ribbon(aes(ymin = lo, ymax = hi),
              alpha = 0.25, color = NA) +
  geom_line(aes(y = fit), linewidth = 1.2, na.rm = TRUE) +
  geom_vline(xintercept = 0.15, linetype = "dashed", linewidth = 0.6, color = "gray30") +
  scale_color_manual(values = c("Bone Marrow" = bm_col, "Spleen" = sp_col)) +
  scale_fill_manual(values = c("Bone Marrow" = bm_col, "Spleen" = sp_col)) +
  scale_x_continuous(limits = c(0, 0.25)) +
  labs(
    x = "Pseudotime",
    y = paste0(assay_name, " expression"),
    title = ""
  ) +
  facet_wrap(~ Gene, ncol = 1, scales = "free_y") +
  theme_classic(base_size = 16) +
  theme(
    plot.title   = element_text( face = "bold", size = 16),
    strip.text   = element_text( face = "bold", size = 14),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.title = element_blank()
  )

```