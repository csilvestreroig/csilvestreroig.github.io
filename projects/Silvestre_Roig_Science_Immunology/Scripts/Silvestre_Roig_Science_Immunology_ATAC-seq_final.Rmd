---
title: "Silvestre_Roig et al. Science Immunology: ATAC-seq data; bulk RNA-seq GMPs"
output: html_notebook
---
Creator: Carlos Silvestre Roig

##ATAC-seq 


### Setup & Packages
```{r setup_and_pkgs}

# Run via Docker so paths are relative to root
rootdir      <- "/projectdir/"

# Load packages: 
pkgs <- c(
  "BiocParallel",
  "BSgenome.Mmusculus.UCSC.mm10",
  "chromVAR",
  "ComplexHeatmap",
  "cowplot",
  "csaw",
  "data.table",
  "edgeR",
  "hexbin",
  "magrittr",
  "magick",
  "matrixStats",
  "memes",
  "motifmatchr",
  "openxlsx",
  "patchwork",
  "SingleCellExperiment",
  "TFBSTools",
  "tidyverse"
)

for(i in pkgs) library(i, character.only = TRUE)


theme_set(theme_bw(base_size=12))

gg2gp <- function(x) ggplot2:::.pt*x

scale_by_quantile <- function (Counts, lower = 0, upper = 1){
  
    if (class(Counts)[1] != "matrix" & class(Counts)[1] != "data.frame") {
      stop("Counts must be a matrix or data.frame")
    }
    if (lower == 0 & upper == 1) 
      return(Counts)
    if (class(Counts)[1] == "data.frame") {
      cnames <- colnames(Counts)
      Counts <- as.matrix(Counts)
      colnames(Counts) <- cnames
    }
    if (upper < 1) {
      qt.upper <- as.numeric(quantile(Counts, upper, na.rm = TRUE))
      Counts[Counts > qt.upper] <- qt.upper
    }
    if (lower > 0) {
      qt.lower <- as.numeric(quantile(Counts, lower, na.rm = TRUE))
      Counts[Counts < qt.lower] <- qt.lower
    }
    return(Counts)
  
}

# Function takes logcpms and does PCA with top 10% most variable genes
make_pca <- function(lcpm, metadata){
  
  metadata <- data.frame(metadata)
  for_pca <- head(order(apply(lcpm, 1, var), decreasing=TRUE), round(nrow(lcpm)*.1))
  pca_all <- prcomp(t(lcpm[for_pca,]))
  percentVar <- pca_all$sdev^2 / sum( pca_all$sdev^2 )*100
  use.pcs <- c(1,2)
  pca_labs <- paste0(paste0("PC", use.pcs, " - "), paste0("Var.expl = ", round(percentVar[use.pcs], 2), "%"))
  
  p <- 
    cbind(pca_all$x, metadata) %>%
    ggplot(aes(x=PC1, y=PC2, color=celltype, shape=tissue)) +
    geom_point(size=3) +
    xlab(pca_labs[1]) + ylab(pca_labs[2])
  
  return(p)
  
}

# Multithreading options
mc_workers <- floor(parallel::detectCores() - 2)
if(mc_workers < 1) mc_workers <- 1
  
Sys.setenv(BIOCPARALLEL_WORKER_NUMBER = mc_workers)

if("doParallel" %in% rownames(installed.packages())){
  
  doParallel::registerDoParallel(cores = mc_workers)
  bpparam <- BiocParallel::DoparParam(RNGseed = 1)
  
} else {
  
  bpparam <- BiocParallel::SerialParam(RNGseed = 1)
  
}

BiocParallel::register(bpparam)

```

### QC/PCA

We start from the raw counts and the metadata deposited at GEO.

```{r load_data}

raw_counts <- read.delim(paste0(rootdir, "/counts_raw_unfiltered.tsv.gz")) %>%
  tibble::column_to_rownames("peak")

metadata <- read.delim(paste0(rootdir, "/metadata.tsv.gz")) %>%
  `rownames<-`(.$sample)

if(!all(colnames(raw_counts) == metadata$sample))
  stop("Counts and metadata not in sync!")

# We use SingleCellExperiment because it's a convenient data container format,
# and since it's ATAC-seq with peak coordinates we make it a RangedSingleCellExperiment
rdata <- str_split_fixed(rownames(raw_counts), ":|-", 3) %>% 
  data.frame %>%
  `colnames<-`(c("chr", "start", "end")) %>%
  makeGRangesFromDataFrame(., starts.in.df.are.0based = TRUE)

sce <- SingleCellExperiment(
  assays = list(counts = raw_counts),
  colData = DataFrame(metadata),
)

rowRanges(sce) <- rdata
rownames(sce) <- rownames(raw_counts)

rm(rdata, raw_counts, metadata)

lvl_celltype <- c("GMP", "PreN", "imNeu", "Neutro")
sce$celltype <- factor(sce$celltype, levels = lvl_celltype)

lvl_tissue <- c("BM", "SP", "Bld")
sce$tissue   <- factor(sce$tissue, levels = lvl_tissue)

sce$lib.size <- apply(assay(sce, "counts"), 2, sum)

```

### Prefiltering, Normalization and QC

Standard normalization

For the sake of documentation, we show here how we first normalized the data using the
default edgeR TMM method. We will then see that there is some non-linear bias in some
samples so we switch in the next chunk to the loess-based normalization from the csaw
package.

```{r norm_default}

# Prefiltering
sce$group
keep <- filterByExpr(assay(sce, "counts"), group = sce$group, min.count=100)
sce <- sce[keep,]

# Normalize using the top 10% of regions with largest average counts
sce$norm.factors <- edgeR::calcNormFactors(assay(sce, "counts"))

logcpm_default <- edgeR::cpm(
  assay(sce, "counts"), lib.size = sce$lib.size * sce$norm.factors, log = TRUE
)

# Inspect by pairwise MA-plots
pairwise_combn <- combn(sort(colnames(logcpm_default)), 2)

keep_these <- lapply(1:ncol(pairwise_combn), function(x){
  s <- gsub("_rep.*", "", pairwise_combn[,x,drop=TRUE])
  if(length(unique(s))==1) return(x) else return(NULL)
})

pairwise_combn <- pairwise_combn[,unlist(keep_these)]

# make the ggplot objects (might take a few seconds)
ma_plots_default_normalization <- lapply(1:ncol(pairwise_combn), function(x){
    
    is_combn <- pairwise_combn[,x]
    df <- 
    data.frame(baseMean=rowMeans(logcpm_default),
               logFC=logcpm_default[,is_combn[1]] - logcpm_default[,is_combn[2]])
    
    g <- 
    ggplot(df, aes(x=baseMean, y=logFC)) +
      geom_hex(bins=200) +
      ggtitle(paste(is_combn, collapse=" vs ")) +
      theme(legend.position="none") +
      geom_hline(yintercept=c(0,-log2(1.5),log2(1.5)), lty=2, linewidth=.25) +
      ylim(c(-3,3)) +
      theme(plot.title=element_text(size=7), axis.title=element_text(size=7))

    return(g)
    
  })

names(ma_plots_default_normalization) <- 
  unlist(lapply(1:ncol(pairwise_combn), function(x) paste(pairwise_combn[,x], collapse="_vs_")))

## A few examples of non-linear bias that motivated the use of the csaw loess method
# GMPs look odd, non-linear bias
wrap_plots(ma_plots_default_normalization[grep("GMP", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("PreN_BM", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("PreN_SP", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("imNeu_Bld", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("imNeu_BM", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("imNeu_SP", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("Neutro_Bld", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("Neutro_BM", names(ma_plots_default_normalization))], ncol=3, nrow=2)
wrap_plots(ma_plots_default_normalization[grep("Neutro_SP", names(ma_plots_default_normalization))], ncol=3, nrow=2)
  
```

### Loess-based normalization

As said above, due to the non-linear bias we switch to loess-based normalization which produces
a per-peak and per sample offset matrix, see the [csaw book](https://bioconductor.org/books/3.16/csawBook/chap-norm.html#dealing-with-trended-biases).

```{r norm_loess}

# Before going to the loess we put a scaling factor based on the default method into the colData
# as this will be used to scale the bigwig files that come in the paper later.
# Since the loess method produces an offset matrix it cannot be used to calculate a single
# scaling factor, and to me knowledge there is no reliable tool that can use an offset matrix
# to scale a bigwig file
sf <- sce$norm.factors * sce$lib.size / 1000000
sf <- sf/exp(mean(log(sf)))
sce$sizeFactor_for_bigwig_scaling <- sf
rm(sf)

sce$norm.factors_default <- sce$norm.factors
sce$norm.factors <- 1

# This is the function for the loess normalization returning a gene by sample offset matrix
sce$totals <- sce$lib.size

assay(sce, "offsets") <- as.matrix(csaw::normOffsets(
  object = sce, assay.id = "counts", se.out = FALSE)
)

assay(sce, "cpm") <- edgeR::cpm(
  y = assay(sce, "counts"), offset = assay(sce, "offsets"), log = FALSE,
)

assay(sce, "logcpm") <- edgeR::cpm(
  y = assay(sce, "counts"), offset = assay(sce, "offsets"), log = TRUE,
)

logcpm_loess <- assay(sce, "logcpm")

ma_plots_loess <- lapply(1:ncol(pairwise_combn), function(x){
    
    is_combn <- pairwise_combn[,x]
    df <- 
    data.frame(baseMean=rowMeans(logcpm_loess),
               logFC=logcpm_loess[,is_combn[1]] - logcpm_loess[,is_combn[2]])
    
    g <- 
    ggplot(df, aes(x=baseMean, y=logFC)) +
      geom_hex(bins=300) +
      ggtitle(paste(is_combn, collapse=" vs ")) +
      theme(legend.position="none") +
      geom_hline(yintercept=c(0,-log2(1.5),log2(1.5)), lty=2, linewidth=.25) +
      ylim(c(-3,3)) +
      theme(plot.title=element_text(size=8))

    return(g)
    
  })

names(ma_plots_loess) <- 
  unlist(lapply(1:ncol(pairwise_combn), function(x) paste(pairwise_combn[,x], collapse="_vs_")))

# Looks "as expected" now
wrap_plots(ma_plots_loess[grep("GMP", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("PreN_BM", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("PreN_SP", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("imNeu_Bld", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("imNeu_BM", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("imNeu_SP", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("Neutro_Bld", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("Neutro_BM", names(ma_plots_loess))], ncol=3, nrow=2)
wrap_plots(ma_plots_loess[grep("Neutro_SP", names(ma_plots_loess))], ncol=3, nrow=2)

rm(logcpm_default, logcpm_loess)

```

### PCA

```{r pca}

make_pca(assay(sce, "logcpm"), colData(sce))

```

### GEO submission

The supplemental files for the GEO upload

```{r, eval = F}

geo <- paste0(rootdir, "/geo_upload")
suppressWarnings(dir.create(geo))

lx <- list(
  counts_raw = assay(sce, "counts"),
  cpm = assay(sce, "cpm"),
  logcpm = assay(sce, "logcpm"),
  norm_offsets = assay(sce, "offsets")
)

lapply(names(lx), function(x){
  
  h <- lx[[x]]
  h <- data.frame(peak = rownames(h), h)
  
  data.table::fwrite(
    x = h, file = paste0(geo, "/", x, ".tsv"),
    sep = "\t", col.names = TRUE, row.names = FALSE,
    quote = FALSE
  )
  NULL
  
}) %>% invisible

system(paste0("gzip --best -f ", geo, "/*.tsv"))
#system(paste0("cd ", geo, " && md5sum *.tsv.gz > MD5.txt"))

```

### Differential analysis

edgeR

Now run the DE analysis with the offset-based normalization.

```{r de}

design <- model.matrix(~0 + group, colData(sce))
colnames(design) <- gsub("group", "", colnames(design))

# We convert to DGEList to natively run the edgeR functions, ensuring that the
# elements (offsets, dispersions) are passed correctly
y <- DGEList(counts = assay(sce, "counts"), samples = colData(sce))
y$samples$lib.size <- sce$lib.size
y$offset <- assay(sce, "offsets")

y <- estimateDisp(y, design)

fit  <- edgeR::glmQLFit(
  y = y, design = design
)

contrasts1 <- list()

contrasts1$GMP_SP_BM    <- makeContrasts(x=GMP_SP - GMP_BM, levels=colnames(design))[,1]
contrasts1$preNeu_SP_BM <- makeContrasts(x=PreN_SP - PreN_BM, levels=colnames(design))[,1]
contrasts1$imNeu_SP_BM  <- makeContrasts(x=imNeu_SP - imNeu_BM, levels=colnames(design))[,1]
contrasts1$imNeu_Bld_BM  <- makeContrasts(x=imNeu_Bld - imNeu_BM, levels=colnames(design))[,1]
contrasts1$imNeu_Bld_SP  <- makeContrasts(x=imNeu_Bld - imNeu_SP, levels=colnames(design))[,1]
contrasts1$Neutro_SP_BM <- makeContrasts(x=Neutro_SP - Neutro_BM, levels=colnames(design))[,1]
contrasts1$Neutro_Bld_BM <- makeContrasts(x=Neutro_Bld - Neutro_BM, levels=colnames(design))[,1]
contrasts1$Neutro_Bld_SP <- makeContrasts(x=Neutro_Bld - Neutro_SP, levels=colnames(design))[,1]

# Test against a fold change of 1.5 which is stringent
results1 <- lapply(names(contrasts1), function(x){
  
  tt <- 
    topTags(edgeR::glmTreat(fit, contrast=contrasts1[[x]], lfc=log2(1.5)), n=Inf) %>% 
    data.frame %>%
    rownames_to_column("region") 
  tt
  
}); names(results1) <- names(contrasts1)

# Summarize DEGs in MA-plots
resMA <- sapply(names(results1), function(x){
  
  res <- results1[[x]]
  
  res %>%
    mutate(significant = factor(if_else(FDR < 0.05, TRUE, FALSE), levels=c("TRUE", "FALSE"))) %>%
    arrange(desc(significant)) %>%
    ggplot(aes(x=logCPM, y=logFC, color=significant)) +
    geom_point() +
    ggtitle(x) +
    scale_color_manual(values=c("dodgerblue", "grey"), drop=FALSE)
  
}, simplify=FALSE)

resMA$GMP_SP_BM
resMA$preNeu_SP_BM
resMA$imNeu_SP_BM
resMA$imNeu_Bld_BM
resMA$imNeu_Bld_SP
resMA$Neutro_SP_BM
resMA$Neutro_Bld_BM
resMA$Neutro_Bld_SP

# Summarize number of DEGs by typical cutoffs
data__overview_differential <-
  lapply(names(results1), function(x){
    
    tt <- results1[[x]]
    up <- tt %>% filter(logFC>0 & FDR<0.05) %>% nrow
    down <- tt %>% filter(logFC<0 & FDR<0.05) %>% nrow
    data.frame(comparison=x, `more.accessible`=up, `less.accessible`=down)
    
  }) %>%
    do.call(rbind, .) %>%
    reshape2::melt(variable.name="category") %>%
    mutate(comparison=factor(comparison, levels=names(results1)))

plot__overview_differential <- data__overview_differential %>%
    ggplot(aes(x=comparison, y=value, fill=category)) +
    geom_bar(position="dodge", stat="identity") +
    guides(x=guide_axis(angle=45), fill=guide_legend(ncol=1)) +
    xlab("") + ylab("number of differential regions") +
    guides(x=guide_axis(angle=45)) +
    theme(legend.position="top", legend.justification = "left") +
    scale_fill_manual(name="", values = c("dodgerblue", "darkgoldenrod2"))

plot__overview_differential

```

### Heatmap

```{r hm1}

# As heatmap plot the union of all significant peaks
peaks_for_heatmap <- do.call(rbind, results1) %>% filter(FDR < 0.05) %>% pull(region) %>% unique

colData(sce) <- droplevels.data.frame(colData(sce))

z <- assay(sce[peaks_for_heatmap,], "logcpm")
z <- t(scale(t(z)))

ann_celltype        <- c("blue", "red", "green", "darkgoldenrod1")
names(ann_celltype) <- levels(sce$celltype)

topann <- HeatmapAnnotation(
  celltype=sce$celltype, 
  col=list(celltype=ann_celltype)
)

row_cl <- hclust(dist(z), method="ward.D2")

to_order <- unlist(lapply(levels(sce$tissue), function(x) paste(x, levels(sce$celltype), sep="_")))
column_order <- unlist(lapply(to_order, function(x) which( paste(sce$tissue, sce$celltype, sep="_")==x)))

# Plot heatmap
ht_opt$message <- FALSE

# Carlos "nice" color palette...
c_ramp <- colorRampPalette(c("#54bebe", "#76c8c8", "#98d1d1", "#badbdb", "#dedad2", "#e4bcad", "#df979e", "#d7658b", "#c80064"))(100)

data__heatmap_differential <- scale_by_quantile(z, .01, .99)

plot__heatmap_differential <- Heatmap(
  data__heatmap_differential, show_row_names=FALSE, 
  cluster_rows=row_cl, cluster_columns=FALSE, column_order=column_order,
  row_split=5,
  column_split = sce$tissue,
  top_annotation=topann, col=c_ramp, name="rel.access",
  raster_by_magick=TRUE
)

pdf(NULL)
plot__heatmap_differential <- draw(plot__heatmap_differential)
dev.off()
plot__heatmap_differential

# Extract the different clusters
hm_1_order <- ComplexHeatmap::row_order(plot__heatmap_differential)
names(hm_1_order) <- paste0("cluster", seq_len(length(hm_1_order)))

# Boxplots to visualize changes -- Cluster 1 for GMPs
a <- 
  data__heatmap_differential[hm_1_order[[1]],] %>%
  data.frame %>%
  dplyr::select(contains("GMP")) %>%
  rownames_to_column("region") %>%
  reshape2::melt(value.name="relative_accessability") %>% 
  separate(col = "variable", sep = "_", into = c("celltype", "organ", "rep")) %>%
  dplyr::select(organ, relative_accessability) %>%
  mutate(celltype="GMP", cluster="C1 (GMP)")

b <- 
  data__heatmap_differential[hm_1_order[[3]],] %>%
  data.frame %>%
  dplyr::select(contains("PreN")) %>%
  rownames_to_column("region") %>%
  reshape2::melt(value.name="relative_accessability") %>% 
  separate(col = "variable", sep = "_", into = c("celltype", "organ", "rep")) %>%
  dplyr::select(organ, relative_accessability) %>%
  mutate(celltype="PreN", cluster="C3 (PreN)")

ab <- rbind(a, b)

plot__C1_C3_GMP_PreN <- ab %>%
  ggplot(aes(x=organ, y=relative_accessability)) +
  geom_boxplot(outlier.shape = NA) +
  geom_point(position = position_jitter(width = .1, height = 0, seed = 1), size=.05, color="grey40") +
  facet_wrap(~cluster, ncol=1, scales="free") +
  theme_bw(base_size = 15) +
  ylab("relative accessability")

plot__C1_C3_GMP_PreN

```

### Motif analysis

Two approaches:

1) Use the clusters from the heatmap and scan each for enrichment.
2) Use all peaks and then use chromVAR to define motifs that separate the celltypes and tissues.

Install MEME

This code here is not executed, it just documents how MEME suite itself and the Bioconductor package memes was installed.
Based on: https://www.bioconductor.org/packages/3.16/bioc/vignettes/memes/inst/doc/install_guide.html
In the Docker container we use it is installed.

Location is `~/meme/bin/` which is where the memes packages in R by default looks for the binaries.

This below is for Linux.

```{bash install_meme, eval=FALSE}

# as of May 2024 this is the latest version
version=5.5.5
wget http://meme-suite.org/meme-software/$version/meme-$version.tar.gz
tar zxf meme-$version.tar.gz
cd meme-$version
./configure --prefix=$HOME/meme --with-url=http://meme-suite.org/ --enable-build-libxml2 --enable-build-libxslt
make
#make test
make install
cd ..
rm -r meme-$version*

```

For Mac, maybe conda `conda install bioconda::meme` and then use `check_meme_install(meme_path = "path/to/meme/binary")`
to specify the path? Untested.
 Run AME

Use AME from the MEME suite via the memes R interface to scan clusters for enrichment of known TFs:

```{r motifs}

tmp_hocomoco <- tempfile()

download.file(
  url = "https://hocomoco11.autosome.org/final_bundle/hocomoco11/core/MOUSE/mono/HOCOMOCOv11_core_MOUSE_mono_meme_format.meme",
  destfile = tmp_hocomoco
)

# Extract the DNA sequences of the cluster regions (from the heatmap clustering)
iter_motifs <- c(names(hm_1_order), "regulome")

grs <- bplapply(iter_motifs, function(x){
  
  if(x == "regulome"){
    
    take <- 1:nrow(sce)
    
  } else {
    
    hh <- hm_1_order[[x]]
    take <- rownames(data__heatmap_differential)[hh]
    
  }
  
  gr <- rowRanges(sce[take,])
  
  # Extract DNA sequence via the BSgenome package
  dna <- getSeq(BSgenome.Mmusculus.UCSC.mm10, gr)
  names(dna) <- as.character(1:length(dna))
  
  return(dna)
  
})

names(grs) <- iter_motifs

motif_enrichments <- bplapply(setdiff(names(grs), "regulome"), BPPARAM = bpparam, function(x){
  
  f <- memes::runAme(
    input = grs[[x]], control = grs$regulome, database = tmp_hocomoco, 
    evalue_report_threshold = .Machine$integer.max) # the machine thingy forces to report everything
  f
  
})

names(motif_enrichments) <- setdiff(names(grs), "regulome")

# Cluster all significant motifs based on scale(-log10(evalue))
unique_motifs <- unlist(lapply(motif_enrichments, function(x) x %>% filter(adj.pvalue < 10^-5) %>% pull(motif_id))) %>% unique

data__enrichment_motifs <- 
  lapply(names(motif_enrichments), function(x){
    
    motif_enrichments[[x]] %>% filter(motif_id %in% unique_motifs) %>% dplyr::select(motif_id, evalue) %>%
      mutate(cluster=x)
    
  }) %>% bind_rows() %>% mutate(score = -log10(evalue)) %>%
    group_by(motif_id) %>%
    mutate(score_scaled = as.numeric(scale(score)), motif_id=gsub("_.*", "", motif_id)) %>%
    pivot_wider(names_from = cluster, id_cols = "motif_id", values_from = "score_scaled") %>%
    column_to_rownames("motif_id")

genes_for_heatmap_right <- unique(c("IRF", "STAT", "RFX", "CEBP", "RUNX", "FOS$", "JUN", "SPI1"))

hm_at_right <- unlist(lapply(genes_for_heatmap_right, function(x) grep(x, rownames(data__enrichment_motifs))))

hm_text <- 5

right_annot <- rowAnnotation(foo=anno_mark(
  at = hm_at_right,
  labels = rownames(data__enrichment_motifs)[hm_at_right],
  side="right",
  labels_gp=gpar(fontsize=gg2gp(hm_text*.75)))
)

# The "motif enrichment" is the scaled -log10(pvalue) of the motif scanning (runAME) from above
plot__enrichment_motifs <- Heatmap(
    as.matrix(data__enrichment_motifs), clustering_method_rows = "ward.D2", 
    cluster_rows = TRUE, cluster_columns = FALSE, 
    col = c("dodgerblue", "black", "yellow"), show_row_names = FALSE, 
    right_annotation = right_annot, show_row_dend = TRUE,
    heatmap_legend_param=list(legend_direction="horizontal",
                              legend_width=unit(4, "cm"),
                              legend_position="bottom",
                              labels_gp=gpar(fontsize=gg2gp(hm_text)),
                              color_bar="continuous",
                              title_position="topcenter",
                              title_gp=gpar(fontsize=gg2gp(hm_text))),
    name="motif enrichment"
  )

pdf(NULL)
plot__enrichment_motifs <- draw(plot__enrichment_motifs, heatmap_legend_side="top")
dev.off()

plot__enrichment_motifs

```

### chromVAR

Use chromVAR as an alternative to motif analysis based on all regions.

```{r chromVAR}

# We give chromVAR the logcpms as input because chromVAR blindly uses the first assay
cp <- log2(edgeR::cpm(y, log = FALSE) + 1)

chromVAR.se <- SummarizedExperiment(
  assays = list(counts = cp),
  colData=colData(sce),
  rowRanges=rowRanges(sce)
)

# Some custom code to feed HOCOMOCO into TFBStools
lbl <- suppressWarnings(readLines("https://hocomoco11.autosome.org/final_bundle/hocomoco11/full/MOUSE/mono/HOCOMOCOv11_full_MOUSE_mono_jaspar_format.txt"))

motifs.hocomoco <- lapply(seq(1, length(lbl)-4, by=5), function(x){
  
  nm <- gsub(">", "", gsub("_MOUSE.*", "", lbl[x]))
  sp <- strsplit(lbl[(x+1):(x+4)], "\t")
  mt <- lapply(sp, function(y) t(as.matrix(as.numeric(y)))) %>% do.call(rbind, .)
  rownames(mt) <- c("A", "C", "G", "T")
  TFBSTools::PFMatrix(ID=nm, name=nm, profileMatrix=mt)
  
}) %>% as(., "SimpleList")

names(motifs.hocomoco) <- unlist(lapply(motifs.hocomoco, function(x) x@ID))

chromVAR.se <- chromVAR::addGCBias(object=chromVAR.se, genome=BSgenome.Mmusculus.UCSC.mm10::BSgenome.Mmusculus.UCSC.mm10)
motifs.jaspar.matched <- motifmatchr::matchMotifs(motifs.hocomoco, rowRanges(chromVAR.se), genome=BSgenome.Mmusculus.UCSC.mm10::BSgenome.Mmusculus.UCSC.mm10)

chromvar.dev <- chromVAR::computeDeviations(object=chromVAR.se, annotations=motifs.jaspar.matched)
chromvar.dev.score <- chromVAR::deviationScores(chromvar.dev) %>% data.frame %>% rownames_to_column("Gene")

data__chromvar_deviations <-
  chromvar.dev.score %>%
  filter(Gene %in% c("RFX2", "KLF6", "RUNX1", "JUNB", "RELB", "IRF1", "IRF3", "IRF5", "IRF8", "IRF9", "CEBPA", "CEBPB", "CEBPD", "CEBPE")) %>%
  reshape2::melt() %>%
  mutate(group=factor(gsub("_rep.*", "", variable)),
         organ=factor(gsub(".*_", "", group), levels=c("BM", "SP", "Bld")),
         celltype=factor(gsub("_.*", "", group), levels=c("GMP", "PreN", "imNeu", "Neutro")))

plot__chromvar_deviations <- 
  data__chromvar_deviations %>%
  ggplot(aes(x=celltype, y=value, fill=organ)) + 
  geom_boxplot() +
  facet_wrap(~Gene, scales="free") + 
  guides(x=guide_axis(angle=45)) +
  xlab("") + ylab("deviation score")

plot__chromvar_deviations

```

### Save data

```{r save}

# save envir:
save.envir <- paste0(rootdir, "/envir.Rdata")
save.image(save.envir)

# Save the sce
saveRDS(sce, paste0(rootdir, "/sce_after_code_atacseq.rds"))

current_packages <- 
  installed.packages()[,c("Package", "Version")] %>% 
  as.data.frame %>% 
  `rownames<-`(NULL) %>%
  dplyr::mutate(p = tolower(Package)) %>% 
  dplyr::arrange(p) %>% 
  dplyr::select(-p)

knitr::kable(current_packages)

sessionInfo()

```


#ATAC-SEQ AND RNA ANALYSIS
###Setup
```{r}
library(dplyr)

# Read (keep original names as-is)
df <- read.delim("GSE109467_readCount_renamed_geneName.txt.gz", check.names = FALSE)

# Force the first column to be called `gene_id` no matter what its current name is
colnames(df)[1] <- "gene_id"

# Build a stable gene label and clean Ensembl version suffixes
df <- df %>%
  mutate(
    gene_id = sub("\\..*$", "", gene_id),  # drop .version
    gene    = ifelse(!is.na(gene_name) & gene_name != "",
                     paste(gene_name, gene_id, sep = "_"),
                     gene_id)
  )

# Pick count/sample columns (everything except known annotation columns)
annot_cols <- c("gene_id","gene_name","Chr","Start","End","Strand","Length","gene")
sample_cols <- setdiff(names(df), annot_cols)

# Keep gene label + counts, set rownames, drop helper column
z <- df[, c("gene", sample_cols)]
rownames(z) <- make.unique(z$gene)
z$gene <- NULL

```

# Evrard dataset
## Load counts
```{r load_data}

# Load counts from GEO
z <- read.delim("GSE109467_readCount_renamed_geneName.txt.gz") %>%
  rename(gene_id = X) %>%
  mutate(gene_id = gsub("\\..*", "", gene_id),
         gene = paste(gene_name, gene_id, sep = "_"))
z <- z[,8:ncol(z)]
rownames(z) <- z$gene
z$gene <- NULL

# Write as SingleCellExperiment in a list so things are collected in a single place
evrard <- list()
evrard$sce_all <- SingleCellExperiment(assays = list(counts = z))
rowData(evrard$sce_all)$gene_name <- gsub("_.*", "", rownames(evrard$sce_all))
evrard$sce_all$label <- gsub("_.*", "", colnames(evrard$sce_all))

# Normalize using edgeR
evrard$sce_all$lib.size <- colSums(assay(evrard$sce_all))

evrard$prefilter_all <- filterByExpr(assay(evrard$sce_all), group = evrard$sce_all$label)
evrard$sce_all$norm.factors <- as.numeric(calcNormFactors(assay(evrard$sce_all[evrard$prefilter_all,])))
evrard$sce_all$effective.lib.size <- evrard$sce_all$lib.size * evrard$sce_all$norm.factors

# Define celltypes based on their unusual labels
evrard$sce_all$celltype <- data.frame(colData(evrard$sce_all)) %>%
  mutate(celltype = case_when(
    label == "GMP" ~ "GMP",
    label == "PN" ~ "preNeu",
    label == "EN" ~ "imNeu",
    label == "LN" ~ "matNeu",
    label == "BN5" ~ "blood_Neu5",
    label == "BN13" ~ "blood_Neu13",
    TRUE ~ "remove"
  )) %>% pull(celltype)

evrard$sce_all$celltype <- factor(evrard$sce_all$celltype, c("GMP", "preNeu", "imNeu", "matNeu", "blood_Neu5", "blood_Neu13"))
evrard$sce_all$celltype

evrard$sce_all$tissue <- factor(if_else(grepl("blood", evrard$sce_all$celltype), "blood", "bm"), c("bm", "blood"))
evrard$sce_all$tissue

```

### Testing

Two tests: 
a) maturation genes as those with changes within BM
b) function genes as those different matNeu BM vs matNeu Bld
```{r}

run_tests <- c("maturation", "functional")

de_results <- bplapply(run_tests, function(x){
  
  if(x == "maturation"){
    
    sce <- evrard$sce_all[,evrard$sce_all$tissue %in% "bm"]
    colData(sce) <- droplevels.data.frame(colData(sce))
    design <- model.matrix(~celltype, colData(sce))
    keep <- filterByExpr(assay(sce), design = design) 
    
  }
  
  if(x == "functional"){
    
    sce <- evrard$sce_all[,evrard$sce_all$celltype %in% c("matNeu", "blood_Neu5", "blood_Neu13")]
    colData(sce) <- droplevels.data.frame(colData(sce))
    design <- model.matrix(~0 + celltype, colData(sce))
    keep <- filterByExpr(assay(sce), design = design) 
    
  }
    
  sce <- sce[keep,]
  disp <- edgeR::estimateDisp(y = assay(sce), lib.size = sce$effective.lib.size, design = design)
  fit <- edgeR::glmQLFit(y = assay(sce), lib.size = sce$effective.lib.size, dispersion = disp$trended.dispersion, design = design)
  
  if(x == "maturation"){
    
    fit <- glmQLFTest(fit, coef = 4:ncol(design))
    
  }
  
  if(x == "functional"){
    
    # matNeu-BM vs the average of the two blood samples
    contrast_use <- rep(0, ncol(design))
    contrast_use[colnames(design) == "celltypematNeu"] <- 1
    w <- which(!colnames(design) == "celltypematNeu")
    contrast_use[w] <- -1 / length(w)
    fit <- glmQLFTest(fit, contrast = contrast_use)
    
  }
  
  
  tt <- topTags(fit, n = Inf)$table %>% rownames_to_column("Gene")
  tt$test <- x
  return(tt)
  
})

names(de_results) <- run_tests

degs_maturation <- de_results$maturation %>%
  filter(FDR < 0.005) %>%
  pull(Gene)

degs_functional <- de_results$functional %>%
  filter(FDR < 0.05) %>%
  pull(Gene)

length(degs_maturation)
length(degs_functional)

# Functional signature is a large subset of the maturation signature
length(intersect(degs_functional, degs_maturation))

lcpm <- edgeR::cpm(assay(evrard$sce_all), lib.size = evrard$sce_all$effective.lib.size, log = TRUE)[degs_maturation,]

scaled <- t(scale(t(lcpm)))
cluster_rows <- hclust(dist(scaled), "ward.D2")
scaled_trim <- scaled
scaled_trim[scaled_trim > quantile(scaled, .95)] <- quantile(scaled, .95)
scaled_trim[scaled_trim < quantile(scaled, .05)] <- quantile(scaled, .05)


######################## HEATMAP ############################
#Extended Figure 9A

library(ComplexHeatmap)
library(circlize)

## 1) Build a continuous color function from your 9-color palette
pal100 <- colorRampPalette(c(
  "#54bebe", "#76c8c8", "#98d1d1", "#badbdb",
  "#dedad2", "#e4bcad", "#df979e", "#d7658b", "#c80064"
))(100)

rng <- range(scaled_trim, na.rm = TRUE)
col_fun <- circlize::colorRamp2(
  seq(rng[1], rng[2], length.out = length(pal100)),
  pal100
)

## 2) Make a column split vector that is 1:1 with the matrix columns
# (Assumes columns of scaled_trim correspond to columns in evrard$sce_all)
stopifnot(all(colnames(scaled_trim) %in% colnames(evrard$sce_all)))

col_split <- evrard$sce_all$celltype[ match(colnames(scaled_trim), colnames(evrard$sce_all)) ]
# Optional: set a desired order for the split strips
# col_split <- factor(col_split, levels = c("LSK","CMP","GMP","PreN","imNeu","Neutro"))

## 3) Draw heatmap with fully named arguments (prevents “argument X matches multiple formal arguments”)
ht <- ComplexHeatmap::Heatmap(
  matrix            = scaled_trim,
  name              = "z",
  col               = col_fun,
  cluster_rows      = cluster_rows,
  cluster_columns   = FALSE,
  column_split      = col_split,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  use_raster        = FALSE,
  row_split         = 4
)

draw(ht) 

#############################Plotting Extended Figure 9B######################
rs <- rowsum(t(scaled), group = evrard$sce_all$celltype)
rmeans <- t(rs / as.numeric(table(evrard$sce_all$celltype)[rownames(rs)]))

rod <- row_order(ht)

l <- lapply(1:length(rod), function(x){
  
  gns <- rownames(scaled_trim)[rod[[x]]]
  r <- rmeans[gns,]
  co <- colMeans(r)
  data.frame(celltype = names(co), value = as.numeric(co), cluster = paste0("C", x)) %>%
    mutate(celltype=factor(celltype, celltype),
           celltype_idx = as.numeric(celltype))
  
}) %>% bind_rows()

library(dplyr)
library(ggplot2)
library(ggh4x)



ll <- l %>%
  mutate(cluster = factor(cluster, levels = c("C1","C2", "C3", "C4"))) %>%
  ggplot(aes(x = celltype, y = value, group = cluster, color = cluster)) +
  geom_line() +
  geom_point(size = 4.8) +  # bigger points
  scale_color_manual(values = c(C1 = "#C96159", C2 = "#41933B", C3 = "#5FA9D9", C4 = "#BF62CB")) +
  theme_classic() +
  theme(
    axis.text.x  = element_text(angle = 45, hjust = 1, size = 14),
    axis.text.y  = element_text(size = 14),
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.title.y = element_text(size = 16, face = "bold"),
    legend.position = "none"
  ) +
  facet_wrap2(
    ~ cluster,
    labeller = labeller(cluster = c(C1 = "Cluster 1", C2 = "Cluster 2", C3 = "Cluster 3", C4 = "Cluster 4")),
    strip = strip_themed(
      background_x = list(
        element_rect(fill = "#C96159", colour = NA),
        element_rect(fill = "#41933B", colour = NA), 
        element_rect(fill = "#5FA9D9", colour = NA),
        element_rect(fill = "#BF62CB", colour = NA)
      ),
      text_x = list(
        element_text(colour = "white", face = "bold", size = 18),  # label size 18
        element_text(colour = "white", face = "bold", size = 18)
      )
    )
  )



ll

names(rod) <- paste0("rnaCluster", 1:length(rod))
rna_evrard_clusters <- lapply(names(rod), function(x){
  data.frame(cluster = x, gene = rownames(scaled_trim)[rod[[x]]])
  
}) %>% bind_rows()
```


### Integrate with ATAC-seq

DE
```{r}
# This is the ATAC-seq object from the 01 script that contains an offset matrix for normalization
setwd("~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/EXPERIMENTS/NS-128_Atac_seq/data_and_code_maturation_thingy")
sce_atac <- as(readRDS("se_atac.rds"), "SingleCellExperiment")


# Some sanitation of the peak coordinates so rowRanges() will be a GRanges object with peak coordinates
tmp <- strsplit(names(rowRanges(sce_atac)), ":|-")

rowRanges(sce_atac) <- matrix(unlist(tmp), byrow = TRUE, ncol = 3) %>%
  data.frame %>%
  setNames(c("chr", "start", "end")) %>%
  makeGRangesFromDataFrame(df = ., starts.in.df.are.0based = FALSE)

rm(tmp)

rownames(sce_atac) <- paste0("Peak_", 1:nrow(sce_atac))

# Now test for differential accessability
d <- data.frame(colData(sce_atac)) %>%
  dplyr::select(celltype, tissue) %>% 
  unique

d$tissue <- factor(d$tissue, c("SP", "Bld", "BM"))

loop_by <- lapply(levels(d$celltype), function(x){
  
  dd <- droplevels.data.frame(d[d$celltype == x,])
  tissues <- combn(levels(dd$tissue), 2)
  celltypes <- rep(x, ncol(tissues))
  m <- matrix(
    data = c(celltypes, t(tissues)),
    byrow = FALSE, ncol = 3
  )
  
  data.frame(m)
  
}) %>% bind_rows() %>% setNames(c("celltypes", "tissue1", "tissue2"))

loop_by[nrow(loop_by) + 1,] <- c("PreN_and_imNeu", "SP", "BM")
loop_by$name <- apply(loop_by, 1, paste, collapse = "_")

loop_by

atac_de_res_list <- bplapply(loop_by$name, function(x){
  
  lo <- loop_by[loop_by$name %in% x,]
  use_celltypes <- strsplit(lo$celltypes, "_and_")[[1]]
  
  sce <- sce_atac[,sce_atac$celltype %in% use_celltypes & sce_atac$tissue %in% c(lo$tissue1, lo$tissue2)]
  colData(sce) <- droplevels.data.frame(colData(sce))
  sce$tissue <- relevel(sce$tissue, ref = lo$tissue2)  
  
  len_celltypes <- length(levels(sce$celltype))
  
  if(len_celltypes == 1){
    
    design <- model.matrix(~tissue, colData(sce))
    
  } else {
    
    design <- model.matrix(~tissue + celltype, colData(sce))
    
  }
  
  if(!is.fullrank(design)) {
    
    warning("Design not full rank")
    return(NULL)
    
  }
  
  # The offsets come from the loess-based normalization in the 01_*.rmd script that we used already for all other ATAC analysis.
  # It replaces the "normal" normalization code.
  disp <- edgeR::estimateDisp(y = assay(sce, "counts"), design = design, offset = assay(sce, "offsets"))
  fit <- edgeR::glmQLFit(y = assay(sce, "counts"), offset = assay(sce, "offsets"), dispersion = disp$trended.dispersion, design = design)
  
  use_coef <- paste0("tissue", lo$tissue1)
  fit <- glmTreat(glmfit = fit, coef = use_coef, lfc = log2(1.1))

  tt <- topTags(fit, n = Inf, sort.by = "none")$table %>% 
    mutate(Peak = rownames(.)) %>%
    relocate("Peak")
  
  tt$comparison <- lo$name
  
  rrg <- rowRanges(sce)[,0]
  mcols(rrg) <- tt
  rrg
  
})

names(atac_de_res_list) <- loop_by$name

# Thats the number of significant (TRUE) or not (FALSE) ATAC-seq peaks globally per comparison
lapply(atac_de_res_list, function(x) summary(x$FDR<0.05)[c("TRUE", "FALSE")])

```

### Annotation
Prepare a mapping of which peaks lie within 50kb of each gene promoters
```{r}

# Now create the annotations, so which ATAC-seq peaks belongs to which of the RNA signature genes
# For this, load a GTF to get transcripts per gene 
gtf_rds <- "gtf.rds"

if(file.exists(gtf_rds)){
  
  gtf <- readRDS(gtf_rds)
  
} else {
  
  gtf <- rtracklayer::import("https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M25/gencode.vM25.annotation.gtf.gz")
  
}

gtf <- gtf[gtf$type == "transcript"]
gtf$gene_id <- gsub("\\..*", "", gtf$gene_id)
gtf$gene <- paste(gtf$gene_name, gtf$gene_id, sep = "_")

# Get the coordinates of the promoters of the signature genes. Output is a GRanges object
# wit the genomic coordinates and a column "signature"
suppressPackageStartupMessages({
  library(GenomicRanges)
  library(GenomicFeatures)
})

# 1) pick the gene metadata column from your GTF
gene_col <- intersect(c("gene", "gene_name", "gene_id", "symbol"), names(mcols(gtf)))
if (length(gene_col) == 0) stop("No gene column found in 'gtf' metadata.")
gene_col <- gene_col[1]

# 2) ensure ATAC ranges are GRanges
atac_gr <- if (inherits(sce_atac, "RangedSummarizedExperiment")) rowRanges(sce_atac) else as(sce_atac, "GRanges")

# 3) build a list of GRanges (one per cluster), already filtered to those overlapping ATAC
gr_list <- lapply(unique(rna_evrard_clusters$cluster), function(xn) {
  current_genes <- rna_evrard_clusters$gene[rna_evrard_clusters$cluster == xn]

  r <- gtf[mcols(gtf)[[gene_col]] %in% current_genes]

  # promoters at TSS (width 1)
  p <- promoters(r, upstream = 1, downstream = 0)

  # carry gene id/name and signature
  mcols(p)$gene <- mcols(r)[[gene_col]]
  mcols(p)$signature <- xn

  # deduplicate by genomic position + gene (avoid multi-transcript duplicates)
  p <- p[!duplicated(paste0(seqnames(p), ":", start(p), ":", strand(p), ":", mcols(p)$gene))]

  # keep only promoters overlapping ATAC peaks
  keep <- overlapsAny(p, atac_gr, ignore.strand = TRUE)
  p[keep]  # returns an empty GRanges if none, not NULL
})

# 4) be safe: drop any non-GRanges (shouldn't happen, but prevents do.call() errors)
gr_list <- Filter(function(x) methods::is(x, "GRanges"), gr_list)

# 5) combine
rna_clusters_ranges <- if (length(gr_list) == 0) GRanges() else do.call(c, unname(gr_list))

rna_clusters_ranges
#########################

# Now extend these promoter positions by 25kb each direction
window_total <- 50000L
rna_clusters_ranges_extended <- GenomicRanges::resize(
  x = rna_clusters_ranges, width = window_total, fix = "center"
)

#Set directory
setwd("~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/EXPERIMENTS/NS-128_Atac_seq/data_and_code_maturation_thingy")

granule <- openxlsx::read.xlsx(
  "Borregaards_JLB_2013_granule_proteome_list.xlsx", check.names = FALSE
) %>%
  reshape2::melt(measure.vars = colnames(.)) %>%
  setNames(c("granule", "gene_name")) %>%
  filter(!is.na(gene_name))

# Remove the few duplicates  
granule <- granule[!granule$gene_name %in% granule$gene_name[duplicated(granule$gene_name)],]

#-------------------------------------------------------------

# This is now-gene-centered annotation. For each of the Evrard signature genes
# we extend the promoters by 50kb and check whether it overlaps a significant ATAC-seq
# peak per comparison.

gene_centered_annotations <- bplapply(names(atac_de_res_list), function(x){
    
  atac <- atac_de_res_list[[x]]
  atac$direction <- data.frame(atac) %>%
    mutate(direction = case_when(FDR < 0.05 & logFC > 0 ~ "more accessible",
                                 FDR < 0.05 & logFC < 0 ~ "less accessible",
                                 TRUE ~ "ns")
    ) %>%
    pull(direction)
  
  atac <- atac[!atac$direction == "ns"]
  
  olap <- as.data.frame(findOverlaps(rna_clusters_ranges_extended, atac))
  olap$gene <- rna_clusters_ranges_extended$gene[olap$queryHits]
  olap$signature <- rna_clusters_ranges_extended$signature[olap$queryHits]
  olap$direction <- atac$direction[olap$subjectHits]
  olap$peak <- atac$Peak[olap$subjectHits]
  
  olap_unique <- olap %>%
    distinct(gene, peak, direction, signature)
  
  olap_annot <- olap_unique %>%
    group_by(gene, direction, signature) %>%
    summarize(peak = paste(unique(peak), collapse = ","))
  
  #olap_annot$n_peaks <- unlist(lapply(olap_annot$peak, function(x) sum(grepl("\\,", x)) + 1))
  
  olap_annot <- olap_annot %>%
    relocate(gene, signature, peak) %>%
    mutate(
      comparison = x, 
      gene_name = gsub("_.*", "", gene),
      maturation_signature = if_else(gene %in% degs_maturation, TRUE, FALSE),
      functional_signature = if_else(gene %in% degs_maturation, TRUE, FALSE),
      both_signature = if_else(maturation_signature & functional_signature, TRUE, FALSE)
    )
  
  olap_final <- left_join(x = olap_annot, y = granule, by = "gene_name") %>%
    dplyr::select(-gene_name)
  
  olap_final
  
}) %>% bind_rows()

gene_centered_annotations$granule <- as.character(gene_centered_annotations$granule)
gene_centered_annotations$granule[is.na(gene_centered_annotations$granule)] <- "NA"
head(gene_centered_annotations)

write.table(gene_centered_annotations, "gene_centered_annotations.tsv", col.names = TRUE, row.names = FALSE, quote = FALSE,
            sep = "\t")
```

Above table has for each RNA signature gene the signature membership (that is the clusters 1-4, the plot is called `ll`),
the ID of the assigned ATAC-seq peak, the number of assigned ATAC-seq peaks per direction, the differential analysis comparison,
whether the gene is part of the maturation and/or functional signature and to which of the granule annotations it intersects.

###Plotting open/close peaks associated with the maturation genes from Evrard et al.
```{r}
library(dplyr)
library(ggplot2)
library(stringr)
library(tidyr)
library(ggh4x)

## clusters to keep (now 4)
sig_keep <- c("rnaCluster1","rnaCluster2","rnaCluster3","rnaCluster4")

## stage order & labels
stages <- c("GMP_SP_BM","PreN_SP_BM","imNeu_SP_BM")
stage_labels <- c("GMP","preNEU","immNEU")

## cluster strip colors (your request)
cluster_strip_cols <- c(
  "Cluster 1" = "#C96159",
  "Cluster 2" = "#41933B",
  "Cluster 3" = "#5FA9D9",
  "Cluster 4" = "#BF62CB"
)

## Open/Closed colors (unchanged)
state_cols <- c(Open = "#88a0dc", Closed = "#ed968c")

## build summarized data
df_counts2 <- gene_centered_annotations %>%
  filter(
    maturation_signature == TRUE,
    comparison %in% stages,
    direction %in% c("more accessible","less accessible")
  ) %>%
  mutate(signature = str_trim(signature)) %>%
  separate_rows(signature, sep = ",") %>%
  filter(signature %in% sig_keep) %>%
  mutate(
    state = if_else(direction == "more accessible", "Open", "Closed"),
    comparison = factor(comparison, levels = stages, labels = stage_labels),
    signature_label = recode(
      signature,
      "rnaCluster1" = "Cluster 1",
      "rnaCluster2" = "Cluster 2",
      "rnaCluster3" = "Cluster 3",
      "rnaCluster4" = "Cluster 4"
    ),
    # lock facet order
    signature_label = factor(signature_label, levels = c("Cluster 1","Cluster 2","Cluster 3","Cluster 4"))
  ) %>%
  group_by(signature_label, comparison, state) %>%
  summarise(n_peaks = n_distinct(peak), .groups = "drop")

## build ggh4x strip backgrounds in facet order
strip_list <- lapply(levels(df_counts2$signature_label), function(lbl) {
  element_rect(fill = cluster_strip_cols[[lbl]], color = NA)
})

## plot
p <- ggplot(df_counts2, aes(x = comparison, y = n_peaks, group = state, color = state)) +
  geom_line(linewidth = 1) +
  geom_point(size = 4.5) +
  geom_text(aes(label = n_peaks),
            vjust = -0.6, size = 4, show.legend = FALSE, color = "black") +
  scale_color_manual(values = state_cols, name = NULL) +
  labs(x = "", y = "Number of peaks") +
  ggh4x::facet_wrap2(
    ~ signature_label, ncol = 2,  # set ncol = 4 if you want all in one row
    strip = ggh4x::strip_themed(
      background_x = strip_list,
      text_x = replicate(length(strip_list),
                         element_text(color = "white", face = "bold", size = 18),
                         simplify = FALSE)
    )
  ) +
  theme_classic() +
  theme(
    axis.title.x = element_text(family = "Arial", size = 16),
    axis.title.y = element_text(family = "Arial", size = 16),
    axis.text.x  = element_text(family = "Arial", size = 14),
    axis.text.y  = element_text(family = "Arial", size = 14),
    legend.text  = element_text(family = "Arial", size = 12),
    strip.text.x = element_text(margin = margin(t = 6, b = 6))
  )

p

```

#ANALYSIS OF BULK RNA-SEQ 
###Loading data
```{r}
# List files in the archive
files_in_archive <- untar("rawcounttables.tar.bz2", list = TRUE)
print(files_in_archive)

# Extract files to a new directory called "rawcounttables"
untar("rawcounttables.tar.bz2", exdir = "rawcounttables")

dir<- "~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/Proteomics and transcriptomics/TRANSCRIPTOME/RNAseq/AMD3100 model/RNAseq_stem_cells"
```

###Reading counts
```{r}
# Load required package
library(DESeq2)

dir<- "~/Dropbox/Backup_Work/Project_Neutrophil_Subsets/Proteomics and transcriptomics/TRANSCRIPTOME/RNAseq/AMD3100 model/RNAseq_stem_cells/rawcounttables/star"

# Read the STAR counts file using file.path to build the full path
star_data <- read.table(file.path(dir, "GENE.tsv"), header = TRUE, sep = "\t")

# 2. Extract columns that contain read counts (columns ending with ".reads")
read_cols <- grep("\\.reads$", colnames(star_data), value = TRUE)
count_matrix <- as.matrix(star_data[, read_cols])
rownames(count_matrix) <- paste(star_data$symbol, star_data$geneid, sep = "_")

# Remove the ".reads" suffix to clean up sample names
sample_names <- sub("\\.reads$", "", read_cols)
colnames(count_matrix) <- sample_names

# Create a gene annotation data frame from star_data
gene_annotation <- star_data[, c("geneid", "symbol", "type")]
rownames(gene_annotation) <- gene_annotation$geneid

# 3. Define sample metadata based on your mapping information
sample_info <- data.frame(
  sample = c("lane1_AGGCAG", "lane1_CTCTCT", "lane2_AGGCAG", "lane2_CTCTCT",
             "lane1_CGTACT", "lane1_TAGGCA", "lane2_CGTACT", "lane2_TAGGCA",
             "lane1_GGACTC", "lane1_TAAGGC", "lane2_GGACTC", "lane2_TAAGGC",
             "lane1_CGAGGC", "lane1_TCCTGA", "lane2_CGAGGC", "lane2_TCCTGA",
             "lane3_AGGCAG", "lane3_CTCTCT", "lane4_AGGCAG", "lane4_CTCTCT",
             "lane3_CGTACT", "lane3_TAGGCA", "lane4_CGTACT", "lane4_TAGGCA",
             "lane3_GGACTC", "lane3_TAAGGC", "lane4_GGACTC", "lane4_TAAGGC",
             "lane3_CGAGGC", "lane3_TCCTGA", "lane4_CGAGGC", "lane4_TCCTGA"),
  condition = c(rep("BM_CMP", 4), rep("BM_GMP", 4), rep("BM_LSK", 4), rep("BM_MEP", 4),
                rep("SP_CMP", 4), rep("SP_GMP", 4), rep("SP_LSK", 4), rep("SP_MEP", 4)),
  replicate = rep(1:4, times = 8),
  reads_millions = c(36.64, 39.50, 38.46, 31.94,    # BM_CMP
                     39.46, 29.38, 25.02, 35.89,    # BM_GMP
                     40.34, 34.24, 34.35, 42.91,    # BM_LSK
                     33.40, 31.61, 42.48, 41.32,    # BM_MEP
                     43.55, 33.65, 30.25, 29.41,    # SP_CMP
                     36.03, 31.78, 27.59, 32.69,    # SP_GMP
                     36.86, 39.54, 38.35, 36.98,    # SP_LSK
                     30.87, 29.22, 35.02, 32.25)    # SP_MEP
)
rownames(sample_info) <- sample_info$sample


# Apply the corrected annotations you provided:
fix_map <- c(
  "lane4_TAGGCA" = "SP_CMP",
  "lane4_CGAGGC" = "SP_GMP",
  "lane4_CTCTCT" = "SP_MEP"
)

ix <- rownames(sample_info) %in% names(fix_map)
sample_info$condition[ix] <- unname(fix_map[rownames(sample_info)[ix]])


# Inspect the sample metadata
print(sample_info)
```

###PCA analysis
```{r}
# Load required packages
library(DESeq2)
library(pheatmap)
library(ggplot2)

# (Assuming that count_matrix and sample_info have been defined as in your previous code)
# For reference, count_matrix was created from star_data (STAR counts file) and sample_info from the mapping info.

# Check the order before reordering
all(colnames(count_matrix) == rownames(sample_info))
# If this returns FALSE, reorder sample_info:
sample_info <- sample_info[colnames(count_matrix), ]

# Now you can create the DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = count_matrix,
                              colData = sample_info,
                              design = ~ condition)

# ====================
# Add gene symbol information to the DESeqDataSet
# ====================
# 'star_data' contains the original gene annotation with columns 'geneid' and 'symbol'
# We match the rownames of dds (which are the ENSEMBL IDs) to star_data$geneid and add the symbol.
rowData(dds)$symbol <- star_data$symbol[match(rownames(dds), star_data$geneid)]
# Optionally, add other annotation columns if desired:
# rowData(dds)$type <- star_data$type[match(rownames(dds), star_data$geneid)]

# ====================
# Quality Control and Transformation
# ====================

# 1. Preliminary Filtering: Remove genes with very low counts (e.g., total counts <= 10)
dds <- dds[rowSums(counts(dds)) > 10, ]

# 2. Apply a variance stabilizing transformation (VST)
# This transformation helps to stabilize the variance across the range of counts.
vsd <- vst(dds, blind = FALSE)

# 3. Visualize Sample-to-Sample Distances via a Heatmap
# Calculate distances between samples using the VST-transformed counts.
sampleDists <- dist(t(assay(vsd)))
# Plot the heatmap of sample distances.
pheatmap(as.matrix(sampleDists),
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         main = "Sample Distance Matrix (VST)")

# 4. Generate a PCA Plot for QC
# Plotting PCA to visualize how samples cluster by condition.
pcaData <- plotPCA(vsd, intgroup = "condition", returnData = TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color = condition)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  ggtitle("PCA of RNAseq Data (VST-transformed)") +
  theme_minimal()
```

###Creating DEGlist
```{r}
library(edgeR)

# 1. Create a DGEList using your bulk count matrix and sample metadata
y <- DGEList(counts = count_matrix, samples = sample_info)

# 1.1 Add gene annotation from the STAR file.
# Here, we use the 'star_data' data frame that was read earlier.
# We assume rownames(count_matrix) correspond to star_data$geneid.
#y$genes <- star_data[match(rownames(y$counts), star_data$geneid), c("geneid", "symbol", "type")]

# 2. Filter lowly expressed genes using filterByExpr
design <- model.matrix(~0 + condition, data = y$samples)
colnames(design) <- gsub('condition', 'label', colnames(design))

keep <- filterByExpr(y, design = design)
y <- y[keep, , keep.lib.sizes = FALSE]

# 3. Normalize the data (TMM normalization)
y <- calcNormFactors(y)

# 4. Create a design matrix based on the 'condition' variable in your metadata
#    Rename the columns so they include the prefix "label" (e.g., labelBM_CMP, etc.)

# 5. Estimate dispersion
y <- estimateDisp(y, design)

# 6. Fit the quasi-likelihood model using glmQLFit
fit <- glmQLFit(y, design, robust = TRUE)
```

###Plotting rnaCluster signatures as heatmap
###rnaCluster1 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster1_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c(
  "0610030E20Rik","1700037C18Rik","1700047M11Rik","2310044K18Rik","2610035D17Rik",
  "4732465J04Rik","4933439K11Rik","6430548M08Rik","6530402F18Rik","9830107B12Rik",
  "A130014A01Rik","A330023F24Rik","A530064D06Rik","Aatk","Abcd2","Abr","Acpp","Actn1",
  "Adam19","Adam8","Ago2","Alox5ap","Amer2","Ampd3","Angel2","Anxa11","Arhgap25",
  "Arhgap27","Arhgef3","Arrb2","Asprv1","Atg3","Atp11a","Atxn10","AU019990",
  "B230208H11Rik","B2m","B4galt5","Bach1","Bag6","Baz2b","Bin3","Bmpr1a","Btg1",
  "C5ar1","C5ar2","Card10","Carns1","Cass4","Ccdc126","Ccdc63","Ccdc88b","Ccrl2",
  "Cd300a","Cdc42ep4","Cdk11b","Ceacam10","Cep19","Cers6","Cfap43","Cflar","Chac1",
  "Chd7","Chil1","Chil5","Chrm3","Cib2","Clec5a","Cln5","Cmtm6","Cmtr1","Coq4",
  "Creb3","Cst3","Ctsh","Cxcr2","D17H6S53E","D8Ertd738e","Dedd2","Dennd1b","Dennd4a",
  "Dgat1","Dhdds","Dhx38","Dhx40","Dmxl2","Dock5","Dstyk","Dusp1","Dvl1","E4f1",
  "Eapp","Efcab14","Efhd2","Egln3","Egr1","Eif2ak3","Elmsan1","Entpd3","F5",
  "F630028O10Rik","Fam160a2","Fam222b","Fosl2","Fpr2","Furin","G0s2","Gadd45a",
  "Gadd45g","Galc","Gale","Gdap2","Gid8","Gm10382","Gm10463","Gm11714","Gm14703",
  "Gm16091","Gm16894","Gm17552","Gm20406","Gm26535","Gm26588","Gm28809","Gm38379",
  "Gm5533","Gmeb1","Gmip","Gnai3","Gpank1","Gpr132","Gramd1b","Gsr","H2-Aa","H2-Ab1",
  "H2-Eb1","Hdc","Hexa","Hook3","Hp","Hsh2d","Ifitm1","Ifitm2","Ifitm6","Igf1r",
  "Igf2r","Il16","Il1f9","Il1r2","Inpp4a","Inpp5a","Itm2b","Itpk1","Itpripl2",
  "Jund","Kat5","Kif23","Kif3b","Klf5","Klhdc4","Lamtor3","Lasp1","Lbr","Lcp1",
  "Lfng","Lgals8","Lrg1","Lrrk2","Lypla2","Lyz2","Map2k4","Map3k14","Map3k9","Mapk14",
  "Max","Mbd2","Mbnl2","Mboat7","Mbp","Mettl9","Mfsd9","Mgll","Mmp25","Mon2","Mtmr12",
  "Mxd1","Myh9","N4bp1","Nadk","Ncf1","Ncf4","Nek6","Neurl3","Nfe2l2","Nfkb1","Nisch",
  "Nt5c2","Nt5e","Ntng2","Nudt7","Oas2","Oas3","Oat","Orai2","Orm2","Pabpc1l","Padi4",
  "Pag1","Pak2","Panct2","Pbx1","Pgd","Pglyrp1","Phactr2","Phlda1","Phospho1","Pigx",
  "Pik3cb","Pik3r5","Pilra","Pilrb1","Pilrb2","Pip4k2a","Pirb","Pithd1","Plaur","Plbd1",
  "Plcl2","Plek","Plekhm1","Pnpla1","Pnpla7","Polr1a","Ppp1ca","Ppp2r5a","Pqlc2",
  "Prickle3","Prkch","Psmb9","Ptpn23","Qsox1","Rab11fip1","Rab43","Rab7","Rab8a","Rad9a",
  "Rapgef2","Rassf5","Rbfa","Rbm18","Retnlg","Rgs2","Rin3","Riok3","Rlf","Rmdn1",
  "Rnf169","Rnf19a","Rnf216","Rogdi","Rps27","Rps6ka4","Rsph1","Rsrc2","Rufy4",
  "S100a11","S100a3","S100a6","S100a8","S100a9","Samsn1","Sema4f","Sema6b","Sgk1","Sin3b",
  "Slc16a3","Slc22a15","Slc27a4","Slc2a3","Slc35a5","Slc35e1","Slc41a3","Slc6a6","Slco4c1",
  "Slfn1","Smad3","Smim14","Smim4","Son","Sorl1","Spg11","Srgn","St3gal4","St3gal5",
  "Stab1","Stard3","Stat1","Stat3","Stfa2l1","Stk38","Stx11","Stx17","Syk","Syp","Szt2",
  "Taf12","Tap1","Tbc1d14","Tcf20","Tcp11l2","Tex15","Tinagl1","Tirap","Tln1","Tmem123",
  "Tmem131","Tmem154","Tmem202","Tmem40","Tmsb4x","Tnfsf13b","Tnrc6b","Tns1","Tpcn2","Trem1",
  "Trem3","Treml4","Trib1","Trim12c","Trim25","Trim30b","Trp53inp2","Trub2","Tubb6","Txnl4b",
  "Ubc","Ugp2","Upf2","Upp1","Vps26b","Vps54","Wdfy4","Wfdc21","Wsb1","Xkr5","Xpa","Zbtb39",
  "Zdhhc18","Zdhhc7","Zfp36l2","Zkscan6","Zswim4","Zxdc"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```

###rnaCluster2 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster2_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c(
  "1700123O20Rik", "1810006J02Rik", "1810055G02Rik", "2010016I18Rik", 
"4930438A08Rik", "Abca13", "Actr3", "Adpgk", "Adtrp", "Agpat2", 
"Ankrd46", "Anxa1", "Anxa7", "Arfgef1", "Bcar3", "Bnip2", "Camp", 
"Cd177", "Cebpe", "Ckap4", "Cldn1", "Clec4a2", "Cops8", "Cpne3", 
"Cyb561a3", "Cyb5r4", "Cyfip2", "Cystm1", "Degs1", "Dennd2d", 
"Dnajb14", "Eea1", "Ets1", "Exoc1", "Exoc2", "Fam71b", "Fbxo10", 
"Fcnb", "Glyr1", "Golim4", "Gpi1", "Gramd2", "Hc", "Heatr6", 
"Hlcs", "Hmgn2", "Hsd11b1", "Ighv1-56", "Itgb2l", "Larp4b", "Ldha", 
"Lin28a", "Lipg", "Ltf", "Map6", "Mapk7", "Med8", "Mgat1", "Mpnd", 
"Mppe1", "Mpzl1", "Mreg", "Msrb2", "Ncam1", "Ndufv3", "Ngp", 
"Nhsl2", "Npepps", "Nt5c3", "Olfml2b", "Orm1", "Paqr7", "Pcmt1", 
"Pfkfb3", "Pgp", "Plin3", "Ppp1cb", "Ptger4", "Rab13", "Rasa2", 
"Rps6kc1", "Sema3g", "Sftpb", "Sh3tc1", "Slc25a24", "Slc31a2", 
"Slco4a1", "Smg9", "Sptlc1", "Sri", "Stard8", "Stradb", "Stxbp5", 
"Syne1", "Tbc1d2", "Tbc1d8", "Thap4", "Ticam1", "Tmem159", "Tmem45a2", 
"Tom1", "Trabd", "Trak2", "Tshr", "Ubr2", "Usp46", "Vps26a", 
"Zfp414"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```

###rnaCluster3 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster3_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c(
 "Abcc4", "Acad8", "Acadl", "Ado", "Akr7a5", "Aldh9a1", "Arv1", 
"Aurka", "Calm3", "Ccdc61", "Cd81", "Cdadc1", "Cdc25a", "Cenpf", 
"Cep41", "Cherp", "Cnep1r1", "Coq5", "Cox10", "Cptp", "Cstf1", 
"Ctnnd1", "Dera", "Dph7", "Dtnbp1", "Dus2", "Egfl7", "Enkd1", 
"Fbxo27", "Fem1a", "Glod4", "Gm16286", "Gm26692", "H2-DMb1", 
"Hibadh", "Hibch", "Hmgxb4", "Hnrnpa3", "Ica1", "Idh3a", "Kdsr", 
"Kif17", "Kntc1", "Lig3", "Lmo1", "Lrrc58", "Map3k4", "Map4k1", 
"Med19", "Mki67", "Mmgt2", "Mogat2", "Mpp7", "Mrpl15", "Mrpl45", 
"Mrrf", "Naglu", "Ncapd3", "Ncoa7", "Ncor2", "Nedd4", "Nucb2", 
"Pask", "Pcnt", "Pds5a", "Pdss2", "Pelp1", "Pgam1", "Pigu", "Ppp1r7", 
"Prc1", "Prpf4", "Ptcd3", "Pxylp1", "Rcbtb2", "Rfc1", "Rnf26", 
"Rngtt", "Rpl3", "Rpn1", "Rprd1b", "Rrp12", "Rtkn2", "Serpinb1a", 
"Sh2d5", "Slc17a9", "Slc35b2", "Slc39a10", "Slc39a11", "Snhg17", 
"Stmn1", "Syngr1", "Tacc2", "Tfap4", "Timm21", "Tmco1", "Tmem138", 
"Tmem216", "Tmx2", "Tnfrsf26", "Tprkb", "Tssc4", "Ttc13", "Tti1", 
"Tubgcp6", "Ubash3a", "Ube2g2", "Ubxn8", "Uggt1", "Uhrf1", "Uhrf1bp1", 
"Usp2", "Usp39", "Vdac2", "Vkorc1l1", "Wdr4", "Zfp282", "Zkscan8", 
"Zmpste24"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```

###rnaCluster4 in GMPs
```{r}
library(dplyr)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(edgeR)

# -----------------------------
# 1) LogCPM from your edgeR DGEList 'y'
# -----------------------------
logcpm <- log2(edgeR::cpm(y, log = FALSE) + 1)

# -----------------------------
# 2) Gene set (rnaCluster4_ALL)  — replace/shorten if you like
# -----------------------------
genes_of_interest <- unique(c("Atp13a1", "Bckdhb", "Dcps", "Dhtkd1", "Dph5", "Ergic1", "Fbxl6", 
"Foxred1", "Gart", "Gm16897", "Gpc3", "Gtf3a", "H2-Ob", "Heatr3", 
"Hsp90ab1", "Mrfap1", "Mri1", "Nt5dc2", "Park7", "Poli", "Psmb8", 
"Rps10", "Skp1a", "Slc14a1", "Slc52a2", "Snhg6", "Sufu", "Tbc1d4", 
"Thyn1", "Txnl4a", "Wdr3", "Zfp61", "Zfp94"
))

# -----------------------------
# 3) Collapse to gene symbols (left of "_"), keep row with max mean if duplicates
# -----------------------------
symbols <- sub("_.*", "", rownames(logcpm))
dup_groups <- split(seq_along(symbols), symbols)
keep_rows <- unlist(lapply(names(dup_groups), function(sym) {
  idx <- dup_groups[[sym]]
  if (length(idx) == 1) return(idx)
  idx[which.max(rowMeans(logcpm[idx, , drop = FALSE], na.rm = TRUE))]
}), use.names = FALSE)

logcpm_sym <- logcpm[keep_rows, , drop = FALSE]
rownames(logcpm_sym) <- symbols[keep_rows]

present <- intersect(genes_of_interest, rownames(logcpm_sym))
if (length(present) == 0) stop("None of the requested genes found after symbol mapping.")
logcpm_sym <- logcpm_sym[present, , drop = FALSE]

# -----------------------------
# 4) Metadata (NO outlier removal)
# -----------------------------
Metadata <- data.frame(
  condition = y$samples$condition,
  row.names = rownames(y$samples)
)
Metadata$tissue <- ifelse(grepl("^BM_", Metadata$condition), "Bone Marrow", "Spleen")

# Keep the same column order in expression
logcpm_sym <- logcpm_sym[, rownames(Metadata), drop = FALSE]

# -----------------------------
# 5) GMP only columns
# -----------------------------
gmp_order <- c("BM_GMP", "SP_GMP")
Metadata <- Metadata[Metadata$condition %in% gmp_order, , drop = FALSE]
Metadata$condition <- factor(Metadata$condition, levels = gmp_order)

col_order <- rownames(Metadata)
mat_gmp  <- logcpm_sym[, col_order, drop = FALSE]

# -----------------------------
# 6) Row-wise scaling computed ONLY within GMP columns
# -----------------------------
mat <- t(scale(t(mat_gmp)))     # scales each gene using only GMP samples

# Trim for visualization
q_upper <- quantile(mat, 0.95, na.rm = TRUE)
q_lower <- quantile(mat, 0.05, na.rm = TRUE)
mat[mat > q_upper] <- q_upper
mat[mat < q_lower] <- q_lower

# -----------------------------
# 7) Annotations
# -----------------------------
sorted_Metadata <- Metadata[order(Metadata$condition), , drop = FALSE]
col_order <- rownames(sorted_Metadata)

ha <- HeatmapAnnotation(
 # condition = sorted_Metadata$condition,
  tissue    = sorted_Metadata$tissue,
  col = list(
    #condition = setNames(c("#2ca02c", "#8c564b"), gmp_order), # BM_GMP, SP_GMP
    tissue    = c("Bone Marrow" = "dodgerblue", "Spleen" = "orchid3")
  ),
  annotation_legend_param = list(
    #condition = list(title = "Condition"),
    tissue    = list(title = "Tissue")
  )
)

# -----------------------------
# 8) Palette & Heatmap
# -----------------------------
hiro_base <- c("#e76254","#ef8a47","#f7aa58","#ffd06f","#ffe6b7",
               "#aadce0","#72bcd5","#528fad","#376795","#1e466e")
pal100 <- colorRampPalette(rev(hiro_base))(100)

ht <- Heatmap(
  mat[, col_order, drop = FALSE],
  name = "Z",
  col = pal100,
  show_row_names    = FALSE,
  show_column_names = FALSE,
  cluster_rows      = TRUE,
  cluster_columns   = FALSE,
  top_annotation    = ha,
  column_split      = sorted_Metadata$condition,
  column_gap        = unit(4, "mm")
)

draw(ht)
```


###ANALYSIS IN SCRNA-SEQ 
```{r}
filename <- file.choose() #I choose sce_scvelo from Velocity folder
sce_scvelo <- readRDS(filename)
```

###Analysis 4 clusters
```{r}
# --- packages ---
library(SingleCellExperiment)
library(escape)         # runEscape / UCell
library(dplyr)
library(tidyr)
library(ggplot2)

# --- 1) Define your gene sets (as provided) ---
rnaCluster1_ALL <- c("0610030E20Rik","1700037C18Rik","1700047M11Rik","2310044K18Rik",
"2610035D17Rik","4732465J04Rik","4933439K11Rik","6430548M08Rik","6530402F18Rik","9830107B12Rik",
"A130014A01Rik","A330023F24Rik","A530064D06Rik","Aatk","Abcd2","Abr","Acpp","Actn1","Adam19",
"Adam8","Ago2","Alox5ap","Amer2","Ampd3","Angel2","Anxa11","Arhgap25","Arhgap27","Arhgef3",
"Arrb2","Asprv1","Atg3","Atp11a","Atxn10","AU019990","B230208H11Rik","B2m","B4galt5","Bach1",
"Bag6","Baz2b","Bin3","Bmpr1a","Btg1","C5ar1","C5ar2","Card10","Carns1","Cass4","Ccdc126",
"Ccdc63","Ccdc88b","Ccrl2","Cd300a","Cdc42ep4","Cdk11b","Ceacam10","Cep19","Cers6","Cfap43",
"Cflar","Chac1","Chd7","Chil1","Chil5","Chrm3","Cib2","Clec5a","Cln5","Cmtm6","Cmtr1","Coq4",
"Creb3","Cst3","Ctsh","Cxcr2","D17H6S53E","D8Ertd738e","Dedd2","Dennd1b","Dennd4a","Dgat1",
"Dhdds","Dhx38","Dhx40","Dmxl2","Dock5","Dstyk","Dusp1","Dvl1","E4f1","Eapp","Efcab14","Efhd2",
"Egln3","Egr1","Eif2ak3","Elmsan1","Entpd3","F5","F630028O10Rik","Fam160a2","Fam222b","Fosl2",
"Fpr2","Furin","G0s2","Gadd45a","Gadd45g","Galc","Gale","Gdap2","Gid8","Gm10382","Gm10463",
"Gm11714","Gm14703","Gm16091","Gm16894","Gm17552","Gm20406","Gm26535","Gm26588","Gm28809",
"Gm38379","Gm5533","Gmeb1","Gmip","Gnai3","Gpank1","Gpr132","Gramd1b","Gsr","H2-Aa","H2-Ab1",
"H2-Eb1","Hdc","Hexa","Hook3","Hp","Hsh2d","Ifitm1","Ifitm2","Ifitm6","Igf1r","Igf2r","Il16",
"Il1f9","Il1r2","Inpp4a","Inpp5a","Itm2b","Itpk1","Itpripl2","Jund","Kat5","Kif23","Kif3b",
"Klf5","Klhdc4","Lamtor3","Lasp1","Lbr","Lcp1","Lfng","Lgals8","Lrg1","Lrrk2","Lypla2","Lyz2",
"Map2k4","Map3k14","Map3k9","Mapk14","Max","Mbd2","Mbnl2","Mboat7","Mbp","Mettl9","Mfsd9",
"Mgll","Mmp25","Mon2","Mtmr12","Mxd1","Myh9","N4bp1","Nadk","Ncf1","Ncf4","Nek6","Neurl3",
"Nfe2l2","Nfkb1","Nisch","Nt5c2","Nt5e","Ntng2","Nudt7","Oas2","Oas3","Oat","Orai2","Orm2",
"Pabpc1l","Padi4","Pag1","Pak2","Panct2","Pbx1","Pgd","Pglyrp1","Phactr2","Phlda1","Phospho1",
"Pigx","Pik3cb","Pik3r5","Pilra","Pilrb1","Pilrb2","Pip4k2a","Pirb","Pithd1","Plaur","Plbd1",
"Plcl2","Plek","Plekhm1","Pnpla1","Pnpla7","Polr1a","Ppp1ca","Ppp2r5a","Pqlc2","Prickle3",
"Prkch","Psmb9","Ptpn23","Qsox1","Rab11fip1","Rab43","Rab7","Rab8a","Rad9a","Rapgef2","Rassf5",
"Rbfa","Rbm18","Retnlg","Rgs2","Rin3","Riok3","Rlf","Rmdn1","Rnf169","Rnf19a","Rnf216","Rogdi",
"Rps27","Rps6ka4","Rsph1","Rsrc2","Rufy4","S100a11","S100a3","S100a6","S100a8","S100a9",
"Samsn1","Sema4f","Sema6b","Sgk1","Sin3b","Slc16a3","Slc22a15","Slc27a4","Slc2a3","Slc35a5",
"Slc35e1","Slc41a3","Slc6a6","Slco4c1","Slfn1","Smad3","Smim14","Smim4","Son","Sorl1","Spg11",
"Srgn","St3gal4","St3gal5","Stab1","Stard3","Stat1","Stat3","Stfa2l1","Stk38","Stx11","Stx17",
"Syk","Syp","Szt2","Taf12","Tap1","Tbc1d14","Tcf20","Tcp11l2","Tex15","Tinagl1","Tirap","Tln1",
"Tmem123","Tmem131","Tmem154","Tmem202","Tmem40","Tmsb4x","Tnfsf13b","Tnrc6b","Tns1","Tpcn2",
"Trem1","Trem3","Treml4","Trib1","Trim12c","Trim25","Trim30b","Trp53inp2","Trub2","Tubb6",
"Txnl4b","Ubc","Ugp2","Upf2","Upp1","Vps26b","Vps54","Wdfy4","Wfdc21","Wsb1","Xkr5","Xpa",
"Zbtb39","Zdhhc18","Zdhhc7","Zfp36l2","Zkscan6","Zswim4","Zxdc")

rnaCluster2_ALL <- c("1700123O20Rik","1810006J02Rik","1810055G02Rik","2010016I18Rik",
"4930438A08Rik","Abca13","Actr3","Adpgk","Adtrp","Agpat2","Ankrd46","Anxa1","Anxa7",
"Arfgef1","Bcar3","Bnip2","Camp","Cd177","Cebpe","Ckap4","Cldn1","Clec4a2","Cops8",
"Cpne3","Cyb561a3","Cyb5r4","Cyfip2","Cystm1","Degs1","Dennd2d","Dnajb14","Eea1","Ets1",
"Exoc1","Exoc2","Fam71b","Fbxo10","Fcnb","Glyr1","Golim4","Gpi1","Gramd2","Hc","Heatr6",
"Hlcs","Hmgn2","Hsd11b1","Ighv1-56","Itgb2l","Larp4b","Ldha","Lin28a","Lipg","Ltf","Map6",
"Mapk7","Med8","Mgat1","Mpnd","Mppe1","Mpzl1","Mreg","Msrb2","Ncam1","Ndufv3","Ngp","Nhsl2",
"Npepps","Nt5c3","Olfml2b","Orm1","Paqr7","Pcmt1","Pfkfb3","Pgp","Plin3","Ppp1cb","Ptger4",
"Rab13","Rasa2","Rps6kc1","Sema3g","Sftpb","Sh3tc1","Slc25a24","Slc31a2","Slco4a1","Smg9",
"Sptlc1","Sri","Stard8","Stradb","Stxbp5","Syne1","Tbc1d2","Tbc1d8","Thap4","Ticam1","Tmem159",
"Tmem45a2","Tom1","Trabd","Trak2","Tshr","Ubr2","Usp46","Vps26a","Zfp414")

rnaCluster3_ALL <- c("Abcc4","Acad8","Acadl","Ado","Akr7a5","Aldh9a1","Arv1","Aurka","Calm3",
"Ccdc61","Cd81","Cdadc1","Cdc25a","Cenpf","Cep41","Cherp","Cnep1r1","Coq5","Cox10","Cptp",
"Cstf1","Ctnnd1","Dera","Dph7","Dtnbp1","Dus2","Egfl7","Enkd1","Fbxo27","Fem1a","Glod4",
"Gm16286","Gm26692","H2-DMb1","Hibadh","Hibch","Hmgxb4","Hnrnpa3","Ica1","Idh3a","Kdsr",
"Kif17","Kntc1","Lig3","Lmo1","Lrrc58","Map3k4","Map4k1","Med19","Mki67","Mmgt2","Mogat2",
"Mpp7","Mrpl15","Mrpl45","Mrrf","Naglu","Ncapd3","Ncoa7","Ncor2","Nedd4","Nucb2","Pask","Pcnt",
"Pds5a","Pdss2","Pelp1","Pgam1","Pigu","Ppp1r7","Prc1","Prpf4","Ptcd3","Pxylp1","Rcbtb2",
"Rfc1","Rnf26","Rngtt","Rpl3","Rpn1","Rprd1b","Rrp12","Rtkn2","Serpinb1a","Sh2d5","Slc17a9",
"Slc35b2","Slc39a10","Slc39a11","Snhg17","Stmn1","Syngr1","Tacc2","Tfap4","Timm21","Tmco1",
"Tmem138","Tmem216","Tmx2","Tnfrsf26","Tprkb","Tssc4","Ttc13","Tti1","Tubgcp6","Ubash3a",
"Ube2g2","Ubxn8","Uggt1","Uhrf1","Uhrf1bp1","Usp2","Usp39","Vdac2","Vkorc1l1","Wdr4","Zfp282",
"Zkscan8","Zmpste24")

rnaCluster4_ALL <- c("Atp13a1","Bckdhb","Dcps","Dhtkd1","Dph5","Ergic1","Fbxl6","Foxred1",
"Gart","Gm16897","Gpc3","Gtf3a","H2-Ob","Heatr3","Hsp90ab1","Mrfap1","Mri1","Nt5dc2","Park7",
"Poli","Psmb8","Rps10","Skp1a","Slc14a1","Slc52a2","Snhg6","Sufu","Tbc1d4","Thyn1","Txnl4a",
"Wdr3","Zfp61","Zfp94")

gene_sets <- list(
  rnaCluster1 = unique(rnaCluster1_ALL),
  rnaCluster2 = unique(rnaCluster2_ALL),
  rnaCluster3 = unique(rnaCluster3_ALL),
  rnaCluster4 = unique(rnaCluster4_ALL)
)

# --- 2) Harmonize with your SCE rownames and drop tiny sets ---
# Escape expects symbols in rownames(sce_scvelo) (usually logcounts). 
present <- rownames(sce_scvelo)
gene_sets_filtered <- lapply(gene_sets, function(gs) intersect(gs, present))

# keep only sets with at least 5 genes present (tweakable)
min_size <- 5
gene_sets_filtered <- gene_sets_filtered[vapply(gene_sets_filtered, length, 1L) >= min_size]

message("Gene set sizes (present in object):")
print(vapply(gene_sets_filtered, length, 1L))

# --- 3) Run ESCAPE with UCell scoring ---
# Choose the assay used for scoring; if you have 'logcounts', ESCAPE will use it by default.
# new.assay.name will store the signature layer; scores are also accessible in colData.
sce_scvelo <- runEscape(
  sce_scvelo,
  gene.sets      = gene_sets_filtered,
  method         = "UCell",
  groups         = 1000,
  cores          = 2,
  maxRank        = 3000,
  min.size       = NULL,             # using our pre-filter above
  new.assay.name = "RNAcluster_signatures"
)
```


```{r}

# ---------- 1) Helper: copy scores from an altExp into colData ----------
add_scores_from_altexp <- function(sce, alt_name, assay_name = NULL, prefix = NULL) {
  stopifnot(alt_name %in% altExpNames(sce))
  ae <- altExp(sce, alt_name)

  # choose assay (prefer "UCell" if available)
  if (is.null(assay_name)) {
    assay_name <- if ("UCell" %in% assayNames(ae)) "UCell" else assayNames(ae)[1]
  }
  mat <- assay(ae, assay_name)     # rows = gene sets (signatures), cols = cells

  # transpose so rows = cells, cols = signatures
  df <- as.data.frame(t(mat))
  if (is.null(prefix)) prefix <- alt_name
  colnames(df) <- paste0(prefix, ".", make.names(rownames(mat)))

  # align to sce column order
  df <- df[colnames(sce), , drop = FALSE]

  colData(sce) <- cbind(colData(sce), S4Vectors::DataFrame(df))
  sce
}

# ---------- 2) Choose which altExp contains the RNA-cluster scores ----------
# EDIT this if needed; below tries to auto-detect a sensible one.
altn <- altExpNames(sce_scvelo)
cand <- altn[grepl("RNA|cluster|signat|ATAC|escape|UCell", altn, ignore.case = TRUE)]
ALTEXP_NAME <- if (length(cand)) cand[1] else altn[1]

# Pull scores into colData (prefers UCell assay if present)
sce_scvelo <- add_scores_from_altexp(sce_scvelo, alt_name = ALTEXP_NAME, assay_name = NULL, prefix = "RNAclust")

# ---------- 3) Prepare plotting data (0–0.15 pseudotime, BM vs Spleen) ----------
# We expect row/term names like rnaCluster1..rnaCluster4 in the altExp.
# After copying, columns became "RNAclust.<signature>"
all_cols <- colnames(colData(sce_scvelo))
wanted <- paste0("RNAclust.", c("rnaCluster1","rnaCluster2","rnaCluster3","rnaCluster4"))
keep_cols <- intersect(all_cols, wanted)
if (length(keep_cols) == 0) stop("Could not find any of: ", paste(wanted, collapse = ", "),
                                 " in colData(sce_scvelo). Check altExp contents.")

meta <- as.data.frame(colData(sce_scvelo))

df_plot <- as.data.frame(colData(sce_scvelo)) %>%
  dplyr::mutate(Organ = as.character(Organ)) %>%
  dplyr::filter(
    Organ %in% c("Bone Marrow", "Spleen"),
    !is.na(velocity_pseudotime),
    velocity_pseudotime >= 0
  ) %>%
  dplyr::select(velocity_pseudotime, Organ, dplyr::all_of(keep_cols)) %>%
  tidyr::pivot_longer(
    cols = dplyr::all_of(keep_cols),
    names_to = "Signature",
    values_to = "Score"
  ) %>%
  dplyr::mutate(
    Signature = sub("^RNAclust\\.", "", Signature),
    Signature = factor(Signature, levels = c("rnaCluster1","rnaCluster2","rnaCluster3","rnaCluster4")),
    Organ     = factor(Organ, levels = c("Bone Marrow","Spleen"))
  )


# ---------- 4) Plot ----------
#spleen until 0.15 (cut) and BM until 0.25
# Define pseudotime ranges for each organ
caps <- c("Bone Marrow" = 0.25, "Spleen" = 0.15)

# 3) Fit LOESS within observed range ∩ organ cap, then predict on that grid
smooth_df <- df_plot %>%
  group_by(Signature, Organ) %>%
  group_modify(~{
    dat <- .x %>%
      arrange(velocity_pseudotime) %>%
      # also cap the TRAINING data to the organ-specific max to avoid extrapolation
      dplyr::filter(velocity_pseudotime <= caps[as.character(.y$Organ)])

    if (nrow(dat) < 5) {
      return(tibble(velocity_pseudotime = numeric(0), fit = numeric(0), se = numeric(0)))
    }

    xmin <- max(0, min(dat$velocity_pseudotime, na.rm = TRUE))
    xmax <- min(caps[as.character(.y$Organ)], max(dat$velocity_pseudotime, na.rm = TRUE))
    if (!is.finite(xmin) || !is.finite(xmax) || xmax <= xmin) {
      return(tibble(velocity_pseudotime = numeric(0), fit = numeric(0), se = numeric(0)))
    }

    xs  <- seq(xmin, xmax, length.out = 200)
    fit <- loess(Score ~ velocity_pseudotime, data = dat, span = 0.6)
    pr  <- predict(fit, newdata = data.frame(velocity_pseudotime = xs), se = TRUE)

    keep <- !(is.na(pr$fit) | is.na(pr$se.fit))
    tibble(
      velocity_pseudotime = xs[keep],
      fit = as.numeric(pr$fit)[keep],
      se  = as.numeric(pr$se.fit)[keep]
    )
  }) %>%
  mutate(
    lo = fit - 1.96 * se,
    hi = fit + 1.96 * se
  ) %>%
  ungroup()

# 4) Plot — organ-colored CI + line; x-axis fixed; SP stops at 0.15, BM can extend to 0.25
ggplot(smooth_df, aes(x = velocity_pseudotime)) +
  geom_ribbon(aes(ymin = lo, ymax = hi, fill = Organ), alpha = 0.35, colour = NA) +
  geom_line(aes(y = fit, colour = Organ), linewidth = 1.2, na.rm = TRUE) +
  geom_vline(xintercept = 0.15, linetype = "dashed", linewidth = 0.6, color = "gray30") +
  scale_color_manual(values = c("Bone Marrow" = "#ADD8E6", "Spleen" = "#c969a1")) +
  scale_fill_manual(values = c("Bone Marrow" = "#ADD8E6", "Spleen" = "#c969a1")) +
  scale_x_continuous(limits = c(0, 0.25)) +
  labs(
    x = "Velocity pseudotime",
    y = "Signature score",
    title = "RNAcluster signature trends across pseudotime"
  ) +
  facet_wrap(~ Signature, ncol = 2, scales = "free_y") +
  theme_classic(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    strip.text = element_text( face = "bold", size = 14),
    legend.title = element_blank()
  )

```

###Plotting  maturation markers: Cxcr2, Cd101
```{r}
library(SingleCellExperiment)
library(dplyr)
library(tidyr)
library(ggplot2)
library(purrr)
library(tibble)

# ----------------------------
# SETTINGS
# ----------------------------
genes <- c("Cxcr2","Cd101")        # genes of interest
bm_col <- "#ADD8E6"
sp_col <- "#c969a1"

# Pick an expression assay (prefer 'logcounts' if present)
assay_name <- if ("logcounts" %in% assayNames(sce_scvelo)) "logcounts" else assayNames(sce_scvelo)[1]

# Keep only genes present
genes_found <- genes[genes %in% rownames(sce_scvelo)]
if (length(genes_found) == 0) stop("None of the requested genes are in 'sce_scvelo' rownames.")

# ----------------------------
# LONG DATA: expression + metadata
# ----------------------------
expr_mat <- as.matrix(assay(sce_scvelo, assay_name)[genes_found, , drop = FALSE])
meta     <- as.data.frame(colData(sce_scvelo))

df_long <- expr_mat %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Gene") %>%
  tidyr::pivot_longer(-Gene, names_to = "Cell", values_to = "Expr") %>%
  dplyr::left_join(
    meta %>%
      tibble::rownames_to_column("Cell") %>%
      dplyr::select(Cell, Organ, velocity_pseudotime),
    by = "Cell"
  ) %>%
  dplyr::mutate(
    Organ = as.character(Organ),
    Gene  = factor(Gene, levels = genes)  # keep input order
  ) %>%
  dplyr::filter(
    Organ %in% c("Bone Marrow","Spleen"),
    !is.na(velocity_pseudotime),
    velocity_pseudotime >= 0, velocity_pseudotime <= 0.25  # keep full BM span; Spleen will be trimmed in prediction
  )

# ----------------------------
# LOESS fits with ORGAN-SPECIFIC x-ranges
# ----------------------------
x_ranges <- list(
  "Bone Marrow" = seq(0, 0.25, length.out = 250),
  "Spleen"      = seq(0, 0.15, length.out = 150)
)

smooth_df <- df_long %>%
  dplyr::group_by(Gene, Organ) %>%
  dplyr::group_modify(~{
    dat <- .x %>% arrange(velocity_pseudotime)
    if (nrow(dat) < 5) {
      message("⚠️ Skipping ", unique(.y$Gene), " / ", unique(.y$Organ), " (too few points)")
      xs <- x_ranges[[as.character(.y$Organ)]]
      return(tibble(velocity_pseudotime = xs, fit = NA_real_, se = NA_real_))
    }
    fit <- loess(Expr ~ velocity_pseudotime, data = dat, span = 0.6)
    xs  <- x_ranges[[as.character(.y$Organ)]]
    pr  <- predict(fit, newdata = data.frame(velocity_pseudotime = xs), se = TRUE)
    tibble(velocity_pseudotime = xs, fit = pr$fit, se = pr$se.fit)
  }) %>%
  dplyr::mutate(
    lo = fit - 1.96 * se,
    hi = fit + 1.96 * se
  ) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(
    Organ = factor(Organ, levels = c("Bone Marrow","Spleen"))
  )

# ----------------------------
# PLOT (smooth lines + shaded CI; BM to 0.25, SP to 0.15; vertical line at 0.15)
# ----------------------------
ggplot(smooth_df, aes(x = velocity_pseudotime, color = Organ, fill = Organ)) +
  geom_ribbon(aes(ymin = lo, ymax = hi),
              alpha = 0.25, color = NA) +
  geom_line(aes(y = fit), linewidth = 1.2, na.rm = TRUE) +
  geom_vline(xintercept = 0.15, linetype = "dashed", linewidth = 0.6, color = "gray30") +
  scale_color_manual(values = c("Bone Marrow" = bm_col, "Spleen" = sp_col)) +
  scale_fill_manual(values = c("Bone Marrow" = bm_col, "Spleen" = sp_col)) +
  scale_x_continuous(limits = c(0, 0.25)) +
  labs(
    x = "Pseudotime",
    y = paste0(assay_name, " expression"),
    title = ""
  ) +
  facet_wrap(~ Gene, ncol = 1, scales = "free_y") +
  theme_classic(base_size = 16) +
  theme(
    plot.title   = element_text( face = "bold", size = 16),
    strip.text   = element_text( face = "bold", size = 14),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    legend.title = element_blank()
  )

```